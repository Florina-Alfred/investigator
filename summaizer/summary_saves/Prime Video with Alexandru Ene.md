# Video Information

**Title   ** : Prime Video with Alexandru Ene  
**Uploader** : corrode  
**Duration** : 1:18:22  
**URL     ** : https://www.youtube.com/watch?v=AArr8YJG6Bs  

---

## Transcription

 Welcome to season five of Rust in Production, a podcast about companies who use Rust to shape the future of infrastructure. My name is Matthias Antler from CRODE and today we talk to Alexander Inne, principal engineer at Prime Video about building modern user interfaces in Rust. Alex, thanks so much for taking the time. Can you introduce yourself and the company you work for? Hi, thanks for inviting me to do this. It's super fun. I'm Alex. I'm a principal engineer for Prime Video London. I've been with them for about eight years, actually almost nine. And before that, I used to do video games, game engines and such things that would be soft. And right now, as I said, I work with Prime Video on the Prime Video app that you have on your living room devices. You do a lot of rust there, so that's why I'm... Yeah. And when you say you did video games, does that mean you also used Rust for that or was it in some other language? No, that was C++ and C sharp for Unity, but mainly C++ are too soft. I don't know what they're using now. I left in 2016 and I learned about Rust in 2017, 2018, I think 2017. So I didn't even know Rust existed. Actually, for most time, I ignored it thinking it's a garbage collected language. But then I saw this guy on YouTube doing demos in type of things with Rust, which is just supporting executables that do art and nice visuals and music. So I was like, oh, wait a second, it doesn't have a garbage collector. So how do they do all of these magic with memory that they keep saying? So that's how I kind of got into it. I am used it then for some tiny emulators in the beginning. And then since then, I'm still building a game in my spare time with Rust. I would say that was my big rust project outside of work and how I got into it. So that's interesting because you come from a C++ background and I think a lot of listeners also have the same background. So what kind of convinced you of Rust in the end? Was it just the fact that it didn't have a garbage collector? Or did you also learn to like the language at some point? So it was, I needed, I wasn't opposed to something other than C++. I just hated build systems in C++. They only work on windows. I could only use Visual Studio with C-Make. It was always a pain. So when I saw something with Rust, it just cargo knew that was mind blowing to me. I mean, people from JavaScript and these other languages are like, yeah, we did that for ages. What are you talking about? But for C++ guy, to do cargo new or cargo run and things to just work, that's just mind blowing at the time to me. And then I started liking bits of the language like enums, things like that. I really, really like those. But yeah, the build system was just magical. I still remember the first time I was watching this guy on YouTube, Ferris. And he was building some demos in things and he starts on, he's building an emulator for N64, I believe. And he starts a new project with cargo new and then cargo run. I was like, what is happening? This is just so cool. So that's how I got into it. Shout out to Ferris. He's also one of the first streamers I watched when I came to Rust. And he's just amazing. I guess everyone should watch his stuff on YouTube. It's still there highly underrated, I would even say, because he really built an N64 emulator from scratch. Not sure how far he got, but the idea itself was so great. Right? And yeah, I wish he would do more rust stuff again. Yeah. We make a petition to bring him back. Or at least on the podcast we should have him. It's a good guy. Yeah. But in C++ you have things like Conan or Package Managers. I'm not familiar about the state of Package Management in C++. Can you enlighten us? So we did, I never used any of those. I think they weren't that popular with game developers at the time. So all I was using is raw, big visual studio and then create a project and then make all my settings. And actually I made a game with some friends that we ported to Linux and none of us. Like we only used directly make files, not even C-Makes. So just put your files in the make file and then in the right place and then it will work. But that's I'm not familiar with. I've never used Conan. People keep bringing it up whenever I mention build systems. But I never tried. And I don't think they supported at the time windows that will not share what the status was. Mainly I'm a Windows developer. I never like only recently I bought a Mac. I think there's something to be said about Conan not being officially part of the C++. How could I say standard or you know it's a separate project. And I guess there's a couple good things about being separate. But in reality for something as central as a package manager in 2025, it's really beneficial to have that as part of the normal ecosystem, part of the runtime that you install. Yeah and it makes for such a nice, smooth start-thing experience. I would say so it is a little bit of a shame. But yeah, I haven't written C++ since 2018. So I'm so happy now. Because all of my site projects used to be in C++, like all sorts of mini game engines or whatever. So now I have used Rust for that and now I use Rust at work. As part of your work, you also probably review a lot of code. How has that review process changed ever since you moved from C++ to Rust? So that actually is really, you probably know because you've interviewed other people, but I can tell you I'm so much more relaxed on code reviews. So for example, we do still have C++ code in my team for the thing we deploy on devices. We have a mini layer that abstracts the system there. So that's written in C++ and comes with virtual machines and all that, that the UI uses later on. So that's in C++. And then in Rust code, it's just like paying attention only to code is doing what it's supposed to do. Not is what are you doing with this memory? Where is it coming from? Where is it going? Even with smart pointers or unique pointers, it's so easy to shoot yourself in the foot as a newbie. And that it's for reviewing code, it's definitely more relaxing. I think it's way easier to write correct code when it comes to memory access. It's just trivial now. The only thing I would say which helped Rust adoption a lot is that it doesn't require years and years of experience. So for example, if I were to propose C++ for the same thing I'm using Rust now for performance reasons, it'd be so hard, it's so hard to onboard people onto C++. So I did see C++ in Unis, but today it does not throw anymore. And very few of them, the new grads even do C++ very few of them. So it's really hard to onboard them. It takes so much time and with Rust is so much easier. So basically the team that switched to Rust in Prime Video, switched from JavaScript to Rust, and it's fine. I mean, it's a new language. It has some onboarding, but imagine switching people only know JavaScript and Java to Rust to C++. It's just going to have crashes everywhere, basically. It's a given. So I would say for adoption from teams that know other languages which isn't C++, but it's just way easier to onboard new people, even new grads or experts. So to summarize the difference between reviewing C++ code and Rust code is an in C++ you need to be really careful with where memory goes. Like memory management is way more central in the review process. Whereas in Rust, it's more about the business logic. It's more about the data flow, but not on a systems level, more on a business logic level. Yes, you're just verifying that this code is achieving what it's supposed to achieve, but not at the low level of what are you doing with this memory. Is it safe to access it? What are you accessing it? Are you sharing it? Weirdly bit and in threads or so on. My main problem with learning C++ in the past was that there was so much hidden knowledge. There were so many unwritten things that you needed to know about this language. It was a big, big language that you need to learn. Whereas in Rust, a lot of things are documented really well. And yes, there is a learning curve, but after this you have pretty good documentation, you have the compiler helping you along and the language feels smaller still. Yeah, the thing with C++ is everyone picks their own flavor. And then there's all sorts of parts of the language that, oh, don't use that, but it's there. Like as a newbie, you don't know what you shouldn't touch. Pointers are still there, like grow pointers there everywhere. And it's so easy to just access them to get around certain things that maybe they would catch, like a unique pointer. Oh, just let me just grab the pointer out of this unique pointer and do my thing or whatever. And it's just maybe share it accidentally to some other place and then save it in some other place. And that's how you get used after free very easy. So that's the problem. Whereas other languages which are newer, like Rust, they don't have this kind of everyone needs to pick a subset problem. They're just use the whole language is fine. The whole features are more cohesive, implemented. So I think that's a big deal. Well, one could argue that one main reason for C++ having all of these caveats is that it's language that has historically grown over time and also is still compatible with C. I'm actually not sure if that is still true or if that's an urban legend by now. I would like to hear your opinion on this. And second, I think when you build larger systems in C++, you run into all of these really non-linear data management problems because this will kind of haunt you and bite you later. It doesn't bite you at the start, usually not at compile time. So you kind of, in a situation where later on you have a larger C++ code base and then suddenly these problems pop up. Yeah, I think one, there is definitely the aspect that it grew over time and even multi-threaded programming became popular when I was in kind of uni or just entering uni when like herb sutter and those guys were like, there's no free lunch. They were writing these articles that so it was a language that just didn't couldn't have predicted how the computing evolves and tours multi-threaded and all of those things. So I think history definitely has a role. It's not like implemented it wrong. They just didn't know. So like the multi-threading wasn't a thing until at this scale until way later on this history of the language. So there were hard to learn lessons by C++ there, whereas Rast already came with this benefit of hindsight and knowledge that was kind of occurred over time. So I think it kind of, it already had way more, so when the design Rast, I assume they had way more knowledge about, okay, what does computing look like today? What are the common problems with other things? Let's fix those in a breaking manner because it's not backwards compatible with C++ in any way, right? You only can, they don't have that constraints. I think they did a really good job, the Rast designers and the people who contributed there. C++ keeps trying to do all of these things. There's various efforts, but honestly I think they should probably stop adding things to the language. Just it's fine. We keep, you know, you keep adding, they added recently something like option or result type of, and it's just so, it looks so ugly. Don't understand how people can criticize Rast for looking ugly. These guys who write C and then you look at C++ and C and C++, they just, God, what's happening? It wasn't that bad when I started honestly. C++ 11, okay, that's fine. It's just, that's a good language. Just that bad thing thinks that. What do you think about all of these recent security efforts by people like Pionist Rustup who try to make C++ safer? Is that going anywhere? I haven't kept up to date with those. I know there's some efforts, Herb also to the Microsoft guy. I think Herb Sutter, it was there. He also had some ideas even with some sort of a smart, but I'm not up to date with what's happening there. In general, about security in the fields I worked in, the thread models were such that you didn't, there were other performance was definitely on the first order of business rather than security. So for video game engines, for example, you're more concerned with that than security, especially for a single player game where you don't, you don't really interact with the outside basically. So do you think that performance and security are always at odds or has rust proven that you can have both? No, you can have both. And I think in good C++ you can have both as well. Today from what I can see, the baseline libraries we use are in C, the open SSL and those things curl, everyone uses curl in everywhere basically and security is super important there. So I think you can get it in both languages, but with various degrees of effort. They're not at odds, but the for certain languages they take definitely more effort than others. Now I'm not sure if you still write any C++, but if so, or even if you just read C++ code nowadays, has your way of dealing with the language changed the writing style or what you consider good C++? So I think one thing that helped me when I learned rust is it kind of formalized the way you're supposed to think about memory and memory access patterns. So I don't think I was ever reviewing C++ code with the idea of who has access in a mutable way to this data. I just didn't have these concepts in my head. I mostly look like at stuff like did you free it in the right time? And it's maybe a vague concept of lifetimes, but not quite as formal as rust makes it. So it definitely gave me at least some vocabulary and more structure way of thinking about catching those issues when I review code. Because I mean, in the beginning, I was just using rust at home for my site projects and passion stuff. So then when I got to work, I was writing C++ and it made me think a little bit more, like, oh, what's the order of access here? How long does this leave? And it gives you a bit of vocabulary. So even if you write C++, I think it makes a good better C++ programmer. Yeah. And what have you done in rust at Prime Video? So I'm just a guy who writes things in rust slowly, recently completing almost the whole app rewrite. So basically, I started working on the, so the team I work in is the client team, which is a little bit special because we work on living room devices. So basically, with the way Prime Video works, we have one application that goes on all of these devices, no matter how performant they are. So they could be all of the gaming consoles, all of the like TVs, set up boxes, streaming sticks, they have the same application running on them, which has a tiny C++ layer and it used to have a JavaScript and React layer on top. And basically, my work started in that C++ layer and then I moved on and started rewriting parts of the JavaScript bit in rust and WebAssembly. So instead of vending things over the air with the JavaScript bundle, now we send a wasm bundle and that people download and we have a WebAssembly virtual machine on the device that runs that code. Mainly for performance reasons, but that's kind of a lot of the work I do. So recently, we started with the UI low-level bits, like for example, just the scene management, animations, things like that, those became rust. Four years, five years ago, I don't remember, maybe four, my timelines are a bit wonky. But we started with a more baseline level and then today we even wrote our own UI SDK in rust to replace the React part. And now our UI client engineers from the end in equivalent are writing rust as their day job for about a year or so. So this application has already been deployed on a lot of devices, but you can imagine it's quite a few given runs on all of the gaming consoles, all of the simple boxes you can think of and TVs, Samsung, LG, Sony, everything. And I guess it also runs on some of the consoles like the PlayStation 4 and 5 and the Xbox, I guess. Yeah, gaming consoles, PS4, 5, all of the Xboxes, Xbox One, Xbox One, there's a lot of them these days, but yeah. So a few people might even have more than one deployment of your applications. I wouldn't be surprised because at least you have a TV, which if you bought it since 2017 or so, it's probably one of these TVs that has apps on them, so it will have the private app because they sometimes even come pre-installed, right? Yes, yes. So they this was one of the problems because as I said, like the hardware in these devices, especially or the cheaper TVs or the set of boxes isn't super powerful, even on the streaming sticks, they're powered by USB, right? So you can't have crazy good hardware inside because it's just whatever USB connection can feed. So basically, ideally, we would write our code into something like C or whatever rust from the beginning, let's say rust wasn't on the table, but we would do everything in C++ and have the best performance ever because we already had it for the native layer. But the problem is on these devices, you don't have app stores. So sometimes your app goes with the firmware update, sometimes it's quite a manual process. So that's why we move more doors, JavaScript and React. So we can keep shipping bug fixes and updates to customers. As a consequence, performance was fantastic, as you can imagine. And we had to put a lot of effort into optimizing that, even so it was very difficult. So rust and web assembly helped a lot on the performance side. And it's code that you can still ship and download and has way better performance than a JavaScript code would have. Because if you imagine JavaScript day, you probably imagine it on a laptop or or whatever, where you have jit enabled. But on these devices, you maybe don't have enough memory to even enable a jit virtual machine like a V8 or whatever. So non jit JavaScript is just so slow. Most people don't know the pain. So yeah. That's one thing. And the other thing is I'm not even sure about garbage collection on these devices. How efficiently it works because it might be that eventually you run out of memory or it's just very laggy, it gets slow when you use it for a longer time. Did you ever encounter that? Yes. So we trigger. So because garbage collection is such a problem in JavaScript, non jitted, you can we disable garbage collection if we have an animation playing. And then we call GCE on the VM manually whenever we know it's safe to do a little bit of stalls, like your idle or whatever. So that was a huge problem as well for us. Because these devices run for a very long time and sometimes people have them on for hours and maybe even days at times. You can't really just close it and start it back up again. That's not an option. Well, we do that if we when we this was actually this was better experienced by the way, then we're going to get there probably, but because you have exceptions, if something unexpected happens, you can just catch it and reboot the whole app. We lost that with transitioning to rust. So I kind of miss a mega tricatch kind of situation, especially with WebAssembly where you don't have stock and mining and you can't quite do the same things. In raw roast, you could unwind the stack. That's true. Yeah, technically panic or throw an arrow and then unwind on that, right? Yeah. If you have a panic, you can handle it if you want it to. But if you cross the rust to WebAssembly boundary, this is where things get really hard. Yeah. So in WebAssembly, it's not possible today. So we lost some features, I would say. But at least it's in general very stable. But if you do have a panic, it is a very unpleasant experience. And actually, one thing I would say writing panic for you code in rust is extremely difficult. Because you can't quite know when a panic would happen. It could be in one of your dependencies. It could be anywhere. It's not like in you can't do anything about it. So one of the panics came and I remember because we got phased because of this edge case somewhere that had to do with the way third party library worked. When the third party library detected that, you shouldn't call certain things in a certain way. It would panic because like this is incorrect. But then the customer has no app anymore. Man, what did you do? So then we had to kind of like fix that and patch it and the return result because the degrees of correctness people sometimes attach to things. I feel there are a bit too much at times where we could be a bit more lenient to return a result but take down the whole thing because in some deep deep library somewhere you found some inputs that were bit dodgy. So if I started such a project, I'd be concerned that I could never update my deployment. Once it's on this box, it will stay there forever and sometimes people don't do any updates on their devices. So it needs to be sort of perfect or at least very close to robust. Was that a concern going in and probably you already had the problem before Rost. So it wasn't a new problem. Yeah, we already had the problem. I mean the Rost code we download as a WebAssembly bundle. So that didn't change. This doesn't sit on the device forever. This is just every time you start the app we download a new app. If one was released. On the C++ side, we did. This is why a lot of low level code that managed our UI scene like doing the animations, creating the scene tree with the nodes, the hierarchy of nodes and all of that was in JavaScript initially. Normally browsers or other UI engines do the C++ for speed, but because I had that fear, that man, whatever I write here, we write and stays here. Mainly forever is not quite true because if something happens, you can ask for an update, work with the partners and but it's a very expensive time-consuming process. Every update would be different. They multiply very fast. So we solved that by minimizing the amount of C++ code that you put on device and has to be there. But then we suffered for performance issues due to the fact that we moved it to JavaScript. But in the meantime, we got lucky and WebAssembly got invented and we could take that technology and deploy it and then vent the Raskode over the air. So now a lot of people have some Rost experience, maybe even some production Rost experience, but they've never really written a platform. Because to me, it sounds like what you're building here is way more foundational than what people touch on a regular basis. Do you have any tips for people who would start with such a large project? Or would you even disagree and say, well, it's not really a platform because we already still have the old C++ layer below, but we just replaced JavaScript with WebAssembly. We, well, it was easy for us because we had the backup of switching to the JavaScript version. Right? So when we were doing this project, it always starts as an experimental. Let's see what could happen. It's not exactly like that, but it starts a bit as a research project and you have a way to go back to the old app. I think one thing I would say about because we replaced React with our own UISDK eventually and that is a pretty big project. I think you're right. It is a huge, it's not foundational because we have only one client, one app that uses us, right? So it's not like we are React that has to service billions of projects. But I don't think you can build these UISDKs without fully deeply understanding the problem in the things you're wanting to replace. Right? So this was for us an eight-year journey overall since I've been there and probably longer because the app existed from before me. And the lessons that you learned are very important in the success of any future replacement. So I would be very cautious in allowing, like for example, if some team comes to me and they say they want to rewrite something in Rust, the first thing I would test them is like how deeply do you understand the problems with your current system? Or are you just a fan like me? And it's nice. Obviously I'm happy when these things happen because I like the language. But I think if you want to be successful here, I would say it's really, really important to deeply, deeply understand all the pain points with the previous thing and the advantages, right? Because it's not like we rewrote some JavaScript in Rust and it's better. Some things are worse. I can't panic anymore, which is really difficult to never panic. Okay? So access on the rear at the wrong point, that's it. No more app. This doesn't happen in JavaScript, you know? So it's a trade-off always. I'll say. It's so true because you need to understand where you're coming from and you need to understand your problem, the main. If you don't have that knowledge, you're missing out on more than 50% of the advantages of porting to any new language, such as Rust. And a lot of people they just think they move to greener pastures, whereas in reality they just switch one problem with another. It's really true. And like we didn't start like this, right? We started with just doing the things we knew Rust would do a good job at because we already knew we did a bad job at in JavaScript, which is managing the three of UI elements. So we moved that away from C++ into JavaScript for updateability. But we knew the trade-off there. We built it and we're like, oh god, this is so slow, but at least we can update it. So when we made a decision, let's keep the React app. But put the management of UI to in Rust and Wobbus, WebAssembly in a different VM, and these two things communicate through some message bus. Then it was kind of an easy choice, starting from a smaller project. And it has a backup. You can always fall back to the thing that works. And it gives the team reading space to kind of research here and deploy it without even having a billion teams collaborating. So this initial thing where we moved the UI three management to Rust, I think was done by seven people over a seven, eight month period. But they didn't interrupt. The other teams didn't even know we switched the thing underneath them. So it was quite nice. When we re-road the UI, everyone knew because there's no other, there's no way you impact a lot of people, but at least you come from a more experienced. You already deployed it in production once. You know, you have quite a bit of experts in the team. So it's a bit of an easier sell. I guess the transition was also easier because you kept the React part and then you had this bridge to WebAssembly and to Rust. So you didn't have to replace the full thing. It wasn't complete rewrite from the get-go. It was more or less a gradual adoption. Yes. We did one thing at a time like that, one screen page at the time, basically. Interesting that you went page by page sort of because the way I thought about it was you kind of started with animations or was that not the entry point? Yeah, we started with the animations and those things, but the pages were still in React. But by the time we moved pages to Rust, it was one page at a time because we didn't want to have on the same screen both JavaScript code, changing the screen and Rust code changing the screen. So the way they're separated at the lower level in the engine, it's two different worlds. Like in the ECS world, they're completely separate entity components systems for those worlds. We use entity components systems there, which is what baby and those engines use in Rust. It's a bit like a 2D engine, but they're like two different separate worlds for us. So we didn't want to deal with. One thing if you do that, which is very problematic is focus management. So focusing a thing that may have been a React UI element from a Rust UI element is just very brittle to keep track of all of those things. So it was simpler for us to move a whole page at a time and simplify things, which helps delivering it faster than that. That means that if you use the app you might have switch between JavaScript and Rust multiple times throughout the interaction. Yeah, yeah. So we started with three pages and then we kind of ordered them in order of use and complexity. This was one of the things that was called out by people in Amazon we review a lot of docs with director, CPUs and so on when we do these big changes and a lot of people are to be concerned that it will look jarring to go from the support smooth rust pages to the old JavaScript pages and how do we make sure it's not like shocking, but it was fine in the end. I mean, it was unavoidable. Did you start with the slowest pages or with the least used pages or what was the strategy? Well, we started from the when you start the app you see the user profiles. So first we replaced that profile page because of a few reasons it allowed us to put some code in production. It wasn't a complicated page because it's like three buttons with a bit of animations. So we didn't require that much UI engine bits to be built. One thing to remember is this UI engine didn't exist. So it was developed at the same time with the app pages. So we picked something that didn't have too many widgets because the UI engine team that made this kind of reacting rust equivalent could build like the concept of a button or focus management and that's it. And then we started with that profile page and once you selected it, you went, we go to the main app page where you have all your movies and we call it the collections page. So the main app page was the second one that we replaced and then from there, that was the most complex one. And then from there, we just replaced things on the journey to play back basically. It was more in order of complexity plus use, I would say. Do you have any metrics in terms of usage of the app? Did you see the number of panics spike or the latency go down? We saw latency go significantly down, especially input latency on the worst devices went from stuff like 400 something milliseconds on the worst device to 30 milliseconds. So it was a huge drop in input latency mainly because we the way react works is very complicated and it does a lot of work to figure things out and to figure out like diffs in the tree and layout is also very slow. So we simplified a lot on that critical path while allowing for certain cute features like every property could be animated and things like that. So simplifying those allow us to have quite a huge gain in performance. That plus rust being just a rust and web assembly just being a faster option than the equivalent JavaScript also. It was I would say two optimizations. One in the logic that we simplify then you get the base layer performance boost from rust. I can certainly relate to that because at least to me when I use any of these applications the input feels like some of the slowest parts of the entire application. It's like annoying if you type a letter for example and it takes ages for it to appear and it annoys me to know and so it must have felt like a free upgrade of my hardware somehow. People didn't message me that they knew I was like oh you finally updated on my TV. It's like yeah. So you could definitely tell especially since this rollout is usually gradual because we wanted to also monitor if they impact like business metrics if people use the more watch more video and those experiments are a bit more long running. So not everyone got it at the same time. Did people only notice it based on speed or were there also any UI differences? So did you take off updating the UI at the same time or did you try to be one to one compatible with the old version? We were well neither. So both the old version so both JavaScript and Rust, so the primary do app went through a redesign and the redesign happened on both JavaScript and then Rust bit implemented the new look only. So they were both both of the UIs were getting kind of a redesign and then Rust came and just did the new thing. We didn't try to do much more than add a few animations I think here but very few. So you have a bit of a, because we wanted to showcase layout animations, those are animations that move an element in such a way that it requires you to recompute the layout of the other elements in the scene just to showcase that it's really fast on the new UI engine in Rust but that's just I think in one or two places used or it was. We tried to keep them as close as possible because then it kind of invalidates all the, you can't quite attribute oh why did people use the app more on Rust maybe it was because of the animation or was it because of the it's hard to find the cause. So we tried to be as one to one with the JavaScript version as possible. Right. The new version had better performance and I'm assuming it also used less memory. That means it allowed you to do more with the devices eventually because now you had more headspace. Now you could experiment more. On the memory side we use more actually because we have still the JavaScript in the same like we didn't delete JavaScript code if we have it in Rust because we kept it there if we needed to switch to a fallback JavaScript, full JavaScript experience. So overall with memory that became quite a bit of quite a bit higher I'd say because now it's like two apps there. Obviously as we port things over the JS part will be deleted or minimized for things like just having logs there or whatever. It's another kind of free thread that you can shove things to with a message bus and then it can do some work. For example right now we send metrics and logs from JavaScript to our backends. So from Rust app we collect them we send them to JavaScript. JavaScript massages them in the right JSON format and then reports things from time to time. So that bit probably is not as critical to delete but yeah. So running JavaScript and WebAssembly and separate threads is interesting. And how do you handle synchronization and stay consistency between those two worlds? You mentioned message bus assist maybe one or multiple I don't know is that the way you generally handle memory synchronization or are there some other patterns? We don't quite fully share memory. Well you can't fully share memory because the way of WebAssembly memory model is. So we just send messages between the two virtual machines and through messages they synchronize their state. So for example let's say you want to synchronize the history stack. Like if you press back where where would that go? You just send a message that hey just update it and so on and then it's just message passing that's that's all it is. And similarly JavaScript can tell the RASVM. It's usually one of them is the source and the other one is just synchronizing with the source. So there's only one source of truth that propagates its state to the virtual machine that just follows. Yeah I guess one of the big advantages of using a message bus here and please correct me if I'm wrong is that you avoid interrupting either world. So for example if the wasm thread does any work it does not need to react immediately to a message coming in right? No yeah and it's also way easier to implement than anything else basically so you can always pull a message whenever you want whenever you have time to deal with them exactly. So you don't they're not obviously if it takes a long time to process a message you've blocked the UI there. So it still has those problems what it gives you a bit of wiggle room on how you yeah. And while you did that transition did you fix any box did you find any logic box in JavaScript any incorrect behavior that you were able to clean up them or even just technical depth as well to reduce the maintenance burden? No but I can tell you one thing I did when I was sporting things from JavaScript to Rust I found a place in the UI that was a bit dodgy and I did it the right way. I think it was to help some transparency was being calculated or I don't remember and I broke the app so basically then I became very careful into turning people please maintain whatever JavaScript was doing does the ground to root we're not we're not thinking here we're porting it over let's not try to it it's really easy to fall into the trap of oh let me do it the right way but then you don't realize that other things on top of you dependent on it being wrong is that whole classic meme of whatever the API is doing is what the API should do and yeah we got bit by that a couple of times me specifically because I was feeling so smug about it's like oh look at the silly thing I fixed it and it's like hey Alex you notice this thing doesn't work at all oh no no so yeah I was with I would say because I rewrote a couple of these systems one of my lessons learned is to just move it with whatever behavior it has and try not to be smart about that and then you can you can iterate on things later but it already this project of rewriting things I feel they take longer than people expect especially since they're usually quite optimistic like oh what's what's so complicated about a UI 3 you know it's just a tree has some properties you updated you traverse the tree you update the children and can do it in a week if you're very you know naive about it but then it turns out it takes a year and then every little bug in the thing needs to be translated because there's stuff that depends on those bugs that people put work around for and then they work differently if you change your code so it's I'll just keep things as they are when I translate them to a new language and then iterate on them I would say I would advise against trying to fix anything yeah I fully agree with that because otherwise you would tackle two problems at once so I know a lot of companies who did the same they started to put over the old logic including the box and everything and then started to clean up that's a way more productive way to to work in that area especially for people that are not no like especially for people that are not comfortable or not experienced with porting code it's a skill that you need to learn it's a different skill than writing code from scratch because you're taking code that already existed and is running in production yeah and what's correct in this scenario is the behavior that is already there not what you think should happen so yeah what correct means changes if you're replacing a system I'd say yeah yeah and speaking of old behavior you must still be able to handle old devices it well as well that don't support web assembly do you have two code bases or two separate code paths or some sort of fallback we still have the javascript pages that are maintained in parallel I would say they're not getting all of the new features like all of the new animations and whatnot but because there's significant even at low percentages worldwide those are a lot of customers that are still due to while historical reasons they're getting only the javascript pages because we didn't put rust on the C++ layer yet so we still have to maintain those and we're going through efforts of kind of backporting this native web assembly VM so we can allow them to run web assembly but for now they're both maintained okay so that means we are in 2025 now how big is the code base nowadays and what's the team size so team size is around 100 or more contributors to the whole project we have a lot of people from back end teams that just want to surface some messaging or some something like that and I have to write a bit of UI code so that's why the number is so high and maybe on the code base size below 100,000 lines of code and more than 50 I would say I never I didn't check it recently also it's a little bit hard to check because we rely heavily on macros because we we replace react and we wanted to give people this kind of gsx like experience of compositing UI so that expands quite a lot so maybe you write five lines of a macro where you compose some UI elements but then the code generated by that is this kind of significance so it's it's hard to tell yeah how would that feel like if I were to write a component in that system would it be easy for me even if I wasn't a Rust developer or would it be very specific you mentioned the macro and it being a bit JSX like would I be able to understand as a travel script developer or would I need to learn Rust for real first so I think on the UI programming side so the the if you're a frontend type of engineer yeah you don't need to learn that much Rust to be able to write code the reason for this is that we are very relaxed with copying data in the UI side and we wrap stuff in RC pointers and things like that so they don't quite hit ownership issues that you are usually having to deal with when you write new Rust code is not super optimal but it doesn't matter compared to JS is way faster anyway so we have this we used to use laptops for this framework for effects and signals and this is very familiar to people who know react or solid JS and those type of things so in that sense it's a bit easier I think in general when you go to Rust from a higher level language it's easier because I don't know what's happening in that browser underneath me when I write react code this code sometimes is being called once every time I click a button this other code is being because it's not like you read the code and that's how it's executed it's always they go into different places so I think in our framework if you read the code this is how things are happening we just expand it so you don't have to write a lot of things by hand but there's no magic except maybe in the effects and signals which are still a little bit like magic because their functions that are called when you set a value on another thing how does it know to call the phone it's just a little bit it's not quite intuitive but it is intuitive to people who know react because they got used to like effects and this type of behavior for me it was just so weird to have this kind of oh whenever what's happening here and turns out what's happening is very ugly it's horribly ugly but you know it's the way reactive UI works right because did you have to port that stuff over to Rust or did you find a different way to solve that so that is already done by Leptos and there's a few reactive frameworks that we relied on we eventually moved a bit away from from it because we want to talk to my certain things and I think the open source project is going a bit in different direction so for simplicity we we had to change some stuff there but basically there are libraries who did this and I think those type of libraries what's possible with Rust UI in general and making it more pleasant to use for people who are front-end engineers do you use a fork of Leptos now that you maintain yourself and which libraries did you mean so there's a few reactive ones I don't remember the name we used to use Leptos and then wrote our forked it and then wrote our own thing on top instead yeah and the library study mentioned the ones that allow you to do the signal or event handling in Rust no this is the signal so Leptos is basically a signals effects things like that they do provide also a way to declaratively do your UI but we didn't just that we only use the signals bit very early on in our conversation we talked about game development and I wonder how much of that design was inspired by game development or how can you compare those two worlds I understand that this is not a game but it feels like you have things that are similar to games like reacting to events some sort of UI some sort of event loop and maybe can you compare those two worlds and how did you model that I'll say basically it's a lot like a game engine under the hood so right now baby popularize this but we did use we also use entity components systems for all our low level bits so while we kept front and engineers happy with Leptos like things with effects and signals and this reactive way of writing UI under the hood it's basically a game engine more or less so it has entity components systems it has systems every every UI element becomes an entity and we attach components to that entity based on what behavior it needs to have and then we have systems like the focus system that looks at every focusable entity and takes the focusable component and does stuff based on your input so it's very very close to game engine and one thing we maybe didn't add and are adding added later which I think makes it a bit different than a game engine is async stuff like we didn't allow async in at all basically because we had no runtime so you can't do anything with a what do you do with the future right so I wish we have added stuff earlier and that's not a concept you usually find in video games at least not the way you write it in rust today with async whatever and Tokyo and all of these things is more like something you find on the back end because async programming is like waiting on multiple things whereas what a game does is processing multiple things is more like thread you create some threads and you do work on those threads instead of waiting so that was the concept that was added a bit later so my understanding is that with entity component systems what you want to do is do work in parallel on the same entity just looking at it from different angles certain facet of say elements and you only deal with these facets but you deal with them in parallel whereas in a classical let's say IO bound system you deal with things concurrently as they come in and so is that where those two worlds collide where you have events that are handled asynchronously or concurrently whereas you kind of want to update the UI in parallel or you want to update all of these properties in parallel with your entities so the place where they kind of interact is when you have UI elements that are waiting on a network called this is not very common in video games but it's very common in UI applications that most of their data comes from some back end it is a little bit on games because you get data from disk that you process and then it gets to shop on your screen but async programming is a bit foreign to game developers as understood by like this kind of idea of a promise or a future that you pull on and it's not the thing that happens often in games I think so because our UI engine is very driven with responses from the back end I think we could have added async stuff a bit earlier I personally so I was the tech leader in this project and I think it was a bit my fault because I didn't quite fully understand async because it's just I think async code is very useful but it's also very hard to read code and have a mental model of how it gets executed and for this reason I've decided to okay let's keep it a bit simple not have any async and then give you some callbacks but then it turns out actually some things would be simpler with async if you don't overdo it so we added it eventually recently so now you can declare a UI component that shows us spinner or something and it will automatically be replaced by something else when we download some data and that's done with async now we call it default components I think they're called in the wild but for those scenarios there I think that's where it differs from a game engine but other than that all of the graphics all of the traversal of things all of the entity components systems that we have are very similar to a game engine yeah I could also see two approaches to that problem one would be the simple way to say you have a proxy around your component and the component itself is completely sync various data proxy that is around it kind of is async and then passes in the data that it receives right that is one way and the other way would be to say let's completely embrace async and do everything async even in the components and it feels like you went from one to the other at some point or you changed your mind on this we didn't so we went with the first one that you described so basically you kind of wrap it into something and then because it's a async block you can write your code and the weight on network calls a bit nicer create the UI component but then the UI itself will be just it replaces something in the three and that's just normal code once it ends executing that future this is the difficulty with async code is very kind of viral it just spreads everywhere and then you need to have this nice sync points with non async code or you either go all in and it's async everywhere but we didn't do that we just allow a sort of a wrapper it goes into a task that executes it and at the end of the day the UI code you're gonna get it's gonna be normal normal code it goes out of that future at some point once usually once we're done with the processing of a network code or some message pass that weights on chavas crypt or something yeah in this case it sounds like it was easier to keep the lower level components the leaf notes sync and have an async runtime around it yeah yeah because ultimately in UI a lot of patterns are like set timeout those type of tasks can easily be async tasks as well that you then run from time to time and that's another place where we you just you just as a UI engineer you have this way of creating a function as shoving it in our executor and then whatever comes out of it might be attached to the UI tree later but it's kind of like an extra feature that you get rather than all the UI code is async everywhere do you port a lot of promises from chavascript to rust or was it not the case there were some around as it things that deal with network usually are like that fetch and then and then do something and then you wait on those we have just a of a way right now that you can say you you write an async function you do your way however you want and then you take that future and send it to us with our API which is a task and this is the task and then we pull it whenever we have time usually per frame but yeah yeah that means you don't usually use vanilla futures you have async functions for the most part and then you pull them from the outside but you don't build up your own future as you would with let's say vanilla JavaScript to promise no no yeah it's an async function that returns the yeah and were you be able to use some of the newer features of CPUs nowadays with simd for example so we do work a lot with the web assembly so we we contribute to the web assembly VM this one get hub it's a web assembly micro runtime so we work quite involved there with the community and also in the web assembly working community working group so we work there on adding threads to web assembly simd is another thing that we are quite keen on that was already done so with these things it's a little we're suffering from our own e-gerness of using things because you want to use the latest things and you're contributing to them but then it kind of creates a built time decision on our side because they're not the web assembly bytecode is not backwards compatible or guaranteed to be backwards compatible let's say well maybe with no with simd it's not so you need the feature enabled with threads you're missing some functions so you could make it work but it's not great so we're a little bit careful of how many of those builds we issue from our pipeline because we don't want to overly complicate our pipeline so it's a bit it's it's a tricky thing we are it didn't help that much because we're not doing a lot of things that were simd for example could help us with maybe if we re-architect some of our lower level systems but we are definitely looking into it and contributing so yeah we're we're interested in those and definitely a hot new space and there's a lot of things going on I also know that there is a concept around garbage collection in web assembly now or at least there's a work in progress sort of draft for this that's kind of crazy as well and I'm not sure if there's any work being done around panic handling in web assembly which would also be kind of interesting right as far as I know there was some work done on stack and winding which is the missing bit that we have on around panics there's kind of these two web assembly's funny because there's these two or more factions that work on it and they have completely different use cases so the browser vendors they care about completely different things than people in the IoT space care about so no one who works on IoT like devices that I know is excited about garbage collection because it's just extra stuff right that you it's useful as a concept and it's useful when you talk about maybe communicating with you but it's just it is a project that I think was useful for so many use cases that it now suffers a little bit because of it because it's pulled into all of these different directions so there's also computer edge type of things that use web assembly and those situations have completely different hardware and feature requirements than someone using it on a IoT device for example or even us on TVs we're kind of in the middle because they're not IoT devices but more simpler is in my view better and then it's the different use with the web browser so right now web assembly is this hot kind of hotbed for like solutions in all of these different fields I'm quite curious how it will evolve but yeah it is definitely evolving quite fast I would say compared to other standards or things all right finally you're a principle engineer and you have a lot of experience now with working with these worlds JavaScript, Rust, C++ web assembly my question is how do you train a team to be productive in Rust without losing any momentum what are your learnings what would you do differently now if you started over how do you get a team from zero to production with Rust this is like really difficult one thing I would say and I found it successful is starting with a small project that's quite self-contained was critical for us and that's for two things first thing you get used to the language and you get used to even even things that people don't quite think about when it comes to rewriting things in Rust at Amazon we have fairly good let's say ecosystem inside of the company but if you're at a company that doesn't have that ecosystem to rely on to deploy some Rust code even deploying something small and keeping itself contained is gonna pave the way for other people to be more productive in the future and that's why I think starting for a small project is what I would definitely advocate another thing that I found successful is finding a place where latency or speed matters to your whoever your customer is in there so for us for example having smooth animations matter and that's how the first project started for us just do the low level three management move these UI elements fast and then people are on board with it because we thought yes of course small animations what do you we have to lose and that some companies maybe have different maps they do but for example if you think about at our scale a team of seven engineers for a year is not a crazy investment maybe it's gonna be one or two people for other companies for six months but it will pay off right if you give people time and if you have a problem that could be solved by Rust I would say usually around stop like processing lots of data or doing something around that and that's kind of an easy way to get your foot through the door how do you use it at scale is then a little bit more tricky and I think here for example we didn't we could have done better so once we did the port of the UI engine even then the team didn't start with 100 people it started with maybe 15 and we grew and grew and grew and grew the problem is after the first two pages we were so successful that we minded it okay now everyone you're using Rust because look at this it's cooler it's faster it's smoother it's people use it more at home use the app more they watch more stuff they don't abandon sessions you know as we saw boosts everywhere but the problem is then you have so much more new people than people who can help them in cold reviews and then it becomes a little bit more difficult so I think they're having a more gradual adoption curve would have been nicer and I would that's a thing you ask me what I would do better I would advocate for us to put the brakes a little bit on moving absolutely everything all at once just iteratively delivering because it's a little bit like throughout what I would say is these kind of things where you where you propose something like let's move this thing to Rust or let's build this new thing in Rust and so on or in any other language it's a little bit like betting a little bit of your the trust that you have in your group or your peers so you gain a bit of trust you ship something you gain more trust you you bet your trust again that you have accumulated on a new project and this is how you can keep the momentum growing as a technologist in my view and yeah I mean this is also like maybe I'm survivorship bias here but if you make the right bets it's fairly it's usually fine if you bet all of your trust on some mega project that then never ships then it's going to be really difficult so I just take more careful bets where I know I have a fairly good chance of delivering on the the training side actually this is a thing we're still figuring it out because people learn so differently and I'm kind of oblivious to this because I'm the guy I don't know read the book guys what's the problem just it's a book we have a time to read it but not everyone knows the same way so I think having a sort of more a better way would be to we're trying to do now some courses and things like that a bit more apply to our UI and we have some documentation but it's more like it's it's knowledge that you get from your peers today it's not like oh I'm consulting the documentation and I'm learning it's like some experienced guy told me in a code review this is better so I'm doing it now and then I'll tell someone else so this is kind of like I don't know knowledge that's we're trying to make a bit more to spread it in a bit more organized way through some courses and things like that another thing I would say in Rust's specific case that really helped us especially everyone's moving fast we want to shift fast with everyone who has time to write documentation right but we one thing we did well was we heavily heavily relied on the ability to write examples in Rust so example dot RS right so everything has an example all the UI elements if you we have hundreds of examples in our if you people usually use VS code our Z I ported our launch JSON to Z but basically we have hundreds of examples you can pick from run and see how they behave put some break points in a very self-contained place so I think that helps for onboarding new people having like a big amount of examples especially with bigger projects so you can kind of get an idea of what's happening easier so that's that's what I would say but they are starting small and then gaining a bit of momentum doing a bit more and a bit more is definitely the way definitely structured training is really important I guess that's also why we are here so that's kind of nice what do you look for in Rust engineers you must have interviewed quite a lot how do you know they you know can quickly pick up the language what are some traits that you see in the real world where you can judge how people will if people will be successful with that language or not oh this is actually quite interesting because we don't test people for language skills on hiring so my opinion as long as you don't some people just don't like the language and then link you move teams or whatever but basically I don't think it's that special I think the whole Rust is hard to learn thing it's just something that it's a meme about this language I'd never quite got it because I kept trying to run a C++ for 10 years man you have no idea what hard is you should tell me Rust is hard like tricy++ but so in my view I think that's a non-issue and in general so at Amazon and actually all of I think all of the big tech companies don't quite test on specific language skills because I think it's assumed that you'll figure it out and learn and so on and also it's also assumed that you'll probably work with more than one language throughout your stay there so it's not necessarily something that but obviously if you're willing to learn that's quite important because if you're if you're resisting this type of change you don't learn it's it's gonna be harder for you to adapt right maybe some people just want to read JavaScript right so then in that case they can move teams or whatever like it's a big company but I would say overall we don't do anything special for Rust training and for Rust for testing Rust skills that's clever yeah I fully understand traditionally the final question is what is your statement to the Rust community well first of all I'm really really happy with everything we have such great array of crates out there to learn from it's one of the communities by the way everyone says that's been friendly as it grew and I've never quite noticed this in another niche community that becomes more popular it usually kind of degrades but the quality in interaction has been very consistent with the Rust community so I really like that one thing I wish we were focusing on more in the ecosystem is build speeds like iteration times just getting those down I think right now we more or less accepted that Rust would be slower to compile or whatever but I think there's examples out there in other languages where people have gotten great results like ZIG for example is pushing a lot on the build speed and the iteration time and I think we all win if we can iterate in our codes super fast like press whatever button you're pressing to run your code and if that's like two seconds it's just magical once it gets past a certain threshold my productivity just I get distracted so I would just to work a lot and investing on if I were like if I had the power to invest in anything in the Rust community I'll say this would be a really good place to invest in iteration times and build speed to decrease them. Who knows maybe at some point we will use cargo ZIG build for building our Rust projects because there is a ZIG compiler backend for Rust nowadays. Yeah especially for debug code where you don't need the whole optimizations from a VMS on yeah yes I would like that. Alex thanks a lot for taking the time I really enjoyed the calm and level headed conversation thanks for the interview thank you this was lovely thanks so much for having me. Rust in production is a podcast by Karot it is hosted by me Matthias Endler and produced by Simon Brcken for show notes transcripts and to learn more about how we can help your company make the most of Rust visit Karot.dev thanks for listening to Rust in production.