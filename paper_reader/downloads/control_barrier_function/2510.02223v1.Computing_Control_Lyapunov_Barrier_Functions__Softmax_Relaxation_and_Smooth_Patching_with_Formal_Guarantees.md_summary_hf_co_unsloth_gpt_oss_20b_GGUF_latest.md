**Title & Citation**  
> **Computing Control Lyapunov‑Barrier Functions: Softmax Relaxation and Smooth Patching with Formal Guarantees** – *Jun Liu & Maxwell Fitzsimmons*, 2024 (re‑published), available on arXiv: 2409.XXXX.

---

### Abstract  
The paper introduces a computational pipeline that yields a single, smooth **Control Lyapunov‑Barrier Function (CLBF)** certifying both asymptotic stability and state‑space safety for control‑affine nonlinear systems.  
Key innovations are:  

1. A **log‑sum‑exp (“softmax”) relaxation** of the nonsmooth max‑barrier formed from state constraints.  
2. A **counterexample‑guided refinement** that iteratively adds half‑space cuts until a strict control‑barrier condition is formally verified.  
3. A **bump‑function patching** that smoothly merges the softmax barrier with an arbitrary Control Lyapunov Function (CLF), yielding a smooth CLBF whenever the CBF and CLF are **strictly compatible** on the safe set boundary.  
4. An **SMT (dReal)**‑based verification workflow that checks the strict barrier and compatibility conditions using a reformulated Farkas‑type lemma.  

Benchmarks, including a 3‑state power‑converter, demonstrate that the safe–stabilization region produced by the method is often less conservative than that obtained via SOS‑based compatible CBF–CLF synthesis.  

---

## 1. Introduction & Motivation  

* Need for **formal safety** (state constraints) in addition to stability in autonomous vehicles, robotics, and industrial processes.  
* Classical tools: CBFs & CLFs separately; optimization‑based QPs (e.g., [1]) require compatibility and can be infeasible or introduce undesired equilibria.  
* A single CLBF enables **universal feedback** (Sontag’s formula [27]) but prior CLBF conditions are typically hard to satisfy (see [5]–[6] and discussion in [18]).  
* Recent converse Lyapunov–barrier theorems ([24]) suggest a CLBF exists iff a strictly compatible CBF–CLF pair exists.  
* The paper builds on this theory to **compute** such a CLBF, improving on the conservative SOS‑based synthesis by leveraging a **softmax barrier** and a **runtime patching** approach with formal guarantees.

---

## 2. Preliminaries & Problem Formulation  

### 2.1 System Model  
Control‑affine dynamics:  

\[
\dot x = f(x)+g(x)u,\quad x\in\mathbb{R}^n,\ u\in\mathbb{R}^m,\ f(0)=0,\ g(0)=0. \tag{1}
\]

Goal: find a state‑feedback \(u=\kappa(x)\) such that  

* **Origin asymptotically stable** for the closed loop \(\dot x = f(x)+g(x)\kappa(x)\).  
* **Safety**: all trajectories starting inside the safe set stay within it.  

### 2.2 Safety Constraints  
State constraints:  

\[
h_i(x)\le 1,\quad i=1,\dots,N, \tag{3}
\]

with continuous gradients \(\nabla h_i\).  
Safe set:  

\[
\mathcal{C}_{\text{safe}}=\bigcap_{i=1}^N\{x\mid h_i(x)\le1\} 
      = \{x\mid h_{\max}(x)\le1\}. \tag{5}
\]

where \(h_{\max}(x)=\max_i h_i(x)\).  
*The exact safe set is the 1‑sublevel of \(h_{\max}\), but \(h_{\max}\) is not differentiable at maxima.*

### 2.3 Problem Statement  
Find a continuously differentiable function \(W:\mathbb{R}^n\to\mathbb{R}\) such that:

* \(C=\{x\mid W(x)\le1\}\) *exactly* equals a controllable subset of \(\mathcal{C}_{\text{safe}}\).  
* \(W\) acts as a Control Lyapunov Function (CLF) on \(C\setminus\{0\}\):

\[
\exists\, u:\; L_fW(x)+L_gW(x)u < 0,\quad \forall x\in C\setminus\{0\}. \tag{6}
\]

The pair \((W,u)\) will then be used to construct a smooth stabilizing controller (e.g., Sontag’s universal formula).

---

## 3. Softmax Relaxation of the Safe Set  

**Idea:** replace the nonsmooth \(h_{\max}\) with a smooth log‑sum‑exp.  

\[
h_{\text{sm}}(x;\tau)=\frac{1}{\tau}\log\Bigl(\sum_{i=1}^N e^{\tau h_i(x)}\Bigr),\;\tau>0. \tag{7}
\]

### 3.1 Property (Proposition 1)  
For all \(\tau>0\) and all \(x\in\mathbb{R}^n\),

\[
h_{\max}(x)\le h_{\text{sm}}(x;\tau)\le h_{\max}(x)+\tfrac{\log N}{\tau}. \tag{8}
\]

Thus the 1‑sublevel of \(h_{\text{sm}}\) is a *guaranteed under‑approximation* of \(\mathcal{C}_{\text{safe}}\) and converges uniformly to the exact set as \(\tau\to\infty\).

### 3.2 Control‑Barrier Condition (Definition 3)  
Define \(\mathcal{C}=\{x\mid h(x)\le1\}\) where \(h\) is smooth.  
\(h\) is a **strict control‑barrier** iff for every \(x\in\partial\mathcal{C}\),

\[
\exists\,u:\; L_fh(x)+L_gh(x)u<0. \tag{12}
\]

This guarantees an *inward pointing Lie derivative* at the boundary (strict invariance).  

**Observation:** The softmax barrier \(h_{\text{sm}}\) often satisfies (12) for a large \(\tau\); otherwise, a counterexample‑guided relaxation (Section 4) can enforce it.

---

## 4. Counterexample‑Guided Refinement  

When (12) fails for \(h_{\text{sm}}\) at a counterexample \(x^\star\in\partial\mathcal{C}\), the algorithm adds a half‑space cut that *removes* \(x^\star\) from \(\mathcal{C}\) while leaving other successful points.

1. **Normal vector at counterexample**:  
   \(\mathbf n=\frac{\nabla h_{\text{sm}}(x^\star;\tau)}{\|\nabla h_{\text{sm}}(x^\star;\tau)\|}\).  

2. **Rotate the normal** by a small angle \(\theta>0\) towards an orthogonal direction \(\mathbf r\perp\mathbf n\):  
   \(\mathbf n_{\text{new}}=\mathbf n\cos\theta+\mathbf r\sin\theta\).  

3. **Define new half‑space** constraint:  
   \(h_{\text{new}}(x)=\mathbf n_{\text{new}}^{\top}x-b_{\text{new}}+1\), with \(b_{\text{new}}=\mathbf n_{\text{new}}^{\top}x^\star-\varepsilon\) (small margin).  

4. **Update barrier**: recompute \(h_{\text{sm}}\) using the expanded constraint set.

The process repeats until either (12) is verified for all boundary points or a maximum number of cuts \(k_{\max}\) is reached.  This yields a “refined” smooth barrier \(h_{\text{ref}}(x;\tau)\) that satisfies the strict CBF condition.

---

## 5. Strict Compatibility of CBF & CLF  

### 5.1 Definitions  

*Control Lyapunov Function (CLF)* \(V:\mathbb{R}^n\to\mathbb{R}\) positive definite: \(V(0)=0,\ V(x)>0\ \forall x\neq0\).  

*Strict compatibility* of a candidate CBF \(h\) and a CLF \(V\) on the set \(C=\{x\mid h(x)\le1\}\) (assumed compact) is:  

1. **(CFB‑CLF)**: for every \(x\in C\setminus\{0\}\),  
   \[
   \exists\,u:\;L_fh(x)+L_gh(x)u<0 \quad\text{and}\quad
   L_fV(x)+L_gV(x)u<0. \tag{15}
   \]  

2. **(Boundary)**: for every \(x\in\partial C\),  
   \[
   \exists\,u:\;L_fh(x)+L_gh(x)u<0 \quad\text{and}\quad
   \nabla V(x)^{\top}g(x)u<0. \tag{16}
   \]  

The strict inequalities ensure *robust* invariance and strict decrease.

### 5.2 SMT Verification (Lemma 3)  

Because (15)-(16) have the structure \(\forall x\,\exists u\,(\cdot)\), we reformulate them using a strict Farkas‑type lemma:

**Lemma 2 (Strict Farkas Reformulation)**  
Let \(A\in\mathbb{R}^{n\times m}\), \(b\in\mathbb{R}^n\).  
\[
Au<b,\,u\in\mathbb{R}^m \iff 
\forall \lambda\in\mathbb{R}_+^n,\,\lambda^{\top}A=0,\sum_i\lambda_i=1 \implies \lambda^{\top}b>0 .
\]

Applied componentwise to the Lie‑derivative inequalities, we get a purely *universal* formula suitable for dReal:

\[
\forall x\in\partial C,\ \forall \lambda\in\Delta:\ 
\lambda^{\top}b(x) > 0,
\]
where \(b(x)=\begin{bmatrix}L_fh(x)+L_gh(x)u\\ L_fV(x)+L_gV(x)u\end{bmatrix}\).

This verifies that for every boundary \(x\) a control \(u\) exists satisfying both inequalities.

### 5.3 Practical Verification  

The verification workflow:  

1. Verify strict CBF condition (12) on \(h_{\text{sm}}\).  
2. Verify CLF condition (21)  
   \[
   \forall x\in C,\ \exists u:\ L_fV+L_gV\,u<0.\tag{21}
   \]  
3. Verify strict compatibility (22) via Lemma 2.  

This is embedded in the LyZNet toolbox ([15]) using the SMT solver dReal ([10]).

---

## 6. Smooth Patching (Theorem 1)  

**Main Result**: Under strict compatibility and compactness of \(C\), one can construct a single smooth function \(W\) satisfying the global CLBF conditions.

### 6.1 Inner Band  

Choose \(\varepsilon\in(0,1)\) such that defining the *band*  
\[
\mathcal{B}_{\varepsilon}=\{x\mid 1-\varepsilon\le h(x)\le1\}
\]
the inequalities (15)-(16) hold *strictly* on \(\mathcal{B}_{\varepsilon}\).

### 6.2 CLF Scaling  

Set \(V_2(x)=\alpha V(x)\) with \(\alpha>0\) chosen so that \(V_2\le1\) on \(C\) (e.g., \(\alpha=1/\max_{x\in C}V(x)\)).

### 6.3 Bump Function  

Define a \(C^1\) bump   
\[
b(x)=\begin{cases}
0,& h(x)\le1-\varepsilon ,\\[2pt]
\bigl(\tfrac{h(x)-1+\varepsilon}{\varepsilon}\bigr)^2\!\bigl(3-2\tfrac{h(x)-1+\varepsilon}{\varepsilon}\bigr),& 1-\varepsilon<h(x)\le1 ,\\[4pt]
1,& h(x)\ge1 .
\end{cases} \tag{18}
\]

Hence \(0\le b(x)\le1\) and \(b\) equals \(0\) in the interior, \(1\) on the exterior.

### 6.4 Patching Formula  

Define  

\[
W(x)= (1-b(x))\,V_2(x)+b(x)\,h(x). \tag{18}
\]

**Properties**  

1. \(W(x)\le1\) iff \(h(x)\le1\), giving \(C=\{W\le1\}\).  
2. On \(C\setminus\{0\}\), for each \(x\) one finds \(u\) such that  

\[
L_fW(x)+L_gW(x)u<0,
\]  

due to the strict inequalities satisfied by \(h\) and \(V_2\) in \(\mathcal{B}_{\varepsilon}\) and pure CLF property of \(V_2\) in interior.  

Thus \(W\) is a Control Lyapunov Function on \(C\) and smooth everywhere (where \(b\) is \(C^1\)).  

**Corollary 1**: There exists a smooth stabilizing controller \(\kappa(x)\) that keeps trajectories inside \(C\) and drives them to the origin asymptotically; e.g., via Sontag’s universal formula or a feasible QP.

---

## 7. Experimental Validation  

Using the **LyZNet** toolbox (Python, compact linear algebra, and dReal SMT solver), the authors tested the pipeline on a variety of 2‑ and 3‑dimensional nonlinear control‑affine systems:

| Example | Dynamics | Safe Constraints | Barrier & CLF | Result |
|--------|----------|------------------|--------------|--------|
| **6.1** (Toy 2D) | \(f(x)=\begin{pmatrix}\cos x_2\\-x_1+x_2\cos x_2\end{pmatrix}\), \(g(x)=\begin{pmatrix}0\\1\end{pmatrix}\) | \(h_1(x)=x_1\sin(x_2)-x_2\le1,\ h_2(x)=x_1x_2+1.5x_1-1\) | Softmax \(h_{\text{sm}}(\tau=4.5)\) + quadratic CLF \(V(x)=x_1^2+2x_2^2\). | Patching yields a CLBF whose 1‑sublevel exactly equals the safe set. Safe trajectories confirm stability; padded CLF outperforms SOS‑based CLBF from [7]. |
| **6.2** (Half‑space) | \(f,g\) from [8] | A single half‑space \(-2-x_1-x_2\le1\) plus box constraints | Softmax \(\tau=3.0\) + quadratic CLF \(V=x_1^2+x_2^2\). | Verified strict compatibility; patched CLBF demonstrates safety and convergence. |
| **6.3** (Elliptic System) | \(f(x)=\begin{pmatrix}x_1\\-\cos x_1-\sin x_2\\0\end{pmatrix}\) | Single half‑space \(-2-x_1-x_2\le1\) | Softmax \(\tau=10.0\) + quadratic CLF \(V=x_1^2+x_2^2\). | Patching yields a smooth CLBF; corresponding trajectories stay safe while reaching origin. |
| **6.4** (3‑state Power Converter) | Pendulum‑type system from [26] | Constraints \(0.1v_{dc}^2+i_d^2-i_q^2-0.25\le1\) and box limits | Softmax \(\tau=3.1\) + quadratic CLF \(V=x^\top x\). | Patching produces a smooth CLBF; simulation confirms safe voltage and current regulation. |  

**Key numerical observations**:  

* For all examples, strict CBF verification (12) required < 0.01 s (SMT time).  
* Verification of strict compatibility (description (22)) took 0.4–0.6 s per example.  
* The resultant safe stabilization region **exceeded** the best SOS‑based compatible CBF‑CLF zones (shown as dotted red curves in Figures 3–7).  

Figures:  

1. **Fig. 1‑2**: Softmax barrier \(h_{\text{sm}}\) for examples 3.1 and 3.2, illustrating tighter under‑approximation than SOS‑based CBFs.  

3. **Fig. 3‑4**: Patched CLBF for Example 6.1, phase portrait, and barrier values along trajectories.  

4. **Fig. 5‑6**: Patched CLBF for Examples 6.2 & 6.3.  

5. **Fig. 7**: Patched CLBF for power‑converter (Example 6.4).  

All figures include a green dashed‑dotted line (verified safe stabilization boundary), blue dashed line (largest safe region via quadratic CLF alone), and dotted red (best SOS‑based result).

---

## 8. Key Claims & Contributions  

| Claim | Evidence / Reasoning |
|-------|------------------------|
| *Softmax barrier yields less conservative safety region than SOS.* | Figures 1–2, concrete comparison curves. |
| *Counterexample‑guided refinement guarantees strict barrier condition.* | Algorithm 1, empirical verification times; ensures that all counterexamples are eliminated. |
| *Strict compatibility can be formally verified via SMT using Farkas‑reformulation.* | Lemma 3, use of dReal. |
| *Smooth patching always possible on the boundary band.* | Theorem 1 proof, construction formula (18). |
| *Resulting CLBF yields a continuous stabilizer via Sontag’s formula.* | Corollary 1; no continuous except at origin. |
| *Computational workflow is efficient (sub‑second SMT checks).* | Reported verification times for examples. |
| *Method extends over existing QP‑based safe‑stabilization.* | No need for compatibility over entire set; only boundary; larger safe region obtained. |
| *Published code and data available for reproducibility.* | GitHub link in Section 6. |

---

## 9. Definitions & Key Terms  

* **Control‑affine system**: \(\dot x=f(x)+g(x)u\).  
* **Safe set**: \(\mathcal{C}_{\text{safe}}=\{x\mid h_{\max}(x)\le1\}\).  
* **Control Lyapunov Function (CLF)**: \(V>0\) (except at 0), and \(\exists u: L_fV+L_gV\,u<0\).  
* **Control Barrier Function (CBF)**: \(h\) with \(h(x)\le1\) defines safe set; strict barrier condition (12).  
* **Strict compatibility**: Conditions (15)-(16).  
* **Softmax / Log‑sum‑exp**: \(h_{\text{sm}}(x;\tau)=\frac{1}{\tau}\log(\sum_i e^{\tau h_i(x)})\).  
* **Bump function**: \(b(x)\) in (18).  
* **SMT solver**: dReal, δ‑complete for nonlinear reals.  
* **Farkas lemma (strict variant)**: Lemma 2 for strict feasibility tests.  

---

## 10. Limitations & Open Questions  

* The method currently handles **scalar** state constraints; extension to vector‑valued constraints or input limits is left for future work.  
* Complexity grows with number of constraints \(N\) and dimension \(n\); while examples are low‑dimensional, scalability to high dimensions is not proven.  
* The algorithm relies on **SMT completeness** for real arithmetic; behavior with highly non‑affine dynamics or discontinuities is unexplored.  
* While strict compatibility is sufficient, it remains an open question whether it is also **necessary**; future work may characterize the boundary precisely.  
* The method adds half‑space cuts; it is unclear whether a minimal or optimal set of cuts can be achieved.  

---

## 11. Future Directions (stated in Conclusion)  

* Incorporate **input constraints** directly into the barrier formulation.  
* Apply **compositional verification** (e.g., decomposition into subsystems) to tackle higher dimensional systems.  
* Explore integration with **model‑predictive control** and **neural controller** synthesis (e.g., LyZNet).  

---

**End of Summary**