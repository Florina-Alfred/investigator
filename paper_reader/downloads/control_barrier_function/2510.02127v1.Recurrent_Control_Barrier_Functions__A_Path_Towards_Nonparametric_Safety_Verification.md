## Recurrent Control Barrier Functions: A Path Towards Nonparametric Safety Verification

Jixian Liu and Enrique Mallada

Abstract -Ensuring the safety of complex dynamical systems often relies on Hamilton-Jacobi (HJ) Reachability Analysis or Control Barrier Functions (CBFs). Both methods require computing a function that characterizes a safe set that can be made (control) invariant. However, the computational burden of solving high-dimensional partial differential equations (for HJ Reachability) or large-scale semidefinite programs (for CBFs) makes finding such functions challenging. In this paper, we introduce the notion of Recurrent Control Barrier Functions (RCBFs), a novel class of CBFs that leverages a recurrent property of the trajectories, i.e., coming back to a safe set, for safety verification. Under mild assumptions, we show that the RCBF condition holds for the signed-distance function, turning function design into set identification. Notably, the resulting set need not be invariant to certify safety. We further propose a data-driven nonparametric method to compute safe sets that is massively parellizable, and trades off conservativeness against computational cost.

with safety guarantees limited by uneven or sparse sampling quality.

## I. INTRODUCTION

Safety is a fundamental requirement in the control of dynamical systems, particularly in safety-critical applications such as robotics, autonomous vehicles, etc. Safety of the system is typically enforced via Hamilton-Jacobi (HJ) reachability analysis [1] or Control Barrier Functions (CBFs) [2], both of which build a function whose superlevel set is a control invariant safe set. Unfortunately, despite the popularity of these methods, their application relies on the computation of the value function or CBF, which presents significant challenges. HJ-reachability analysis requires solving partial differential equations, which suffers from the curse of dimensionality [3]. The synthesis of valid CBFs often requires solving a Sum-of-Squares (SOS) optimization problem, which is also computationally demanding when applied to high-dimensional systems [4], [5].

To reduce the computational burden, some data-driven methods have been proposed. DeepReach greatly improves computational efficiency for high-dimensional HJ reachability by using neural PDE solvers, but its learning-based approximation limits interpretability despite strong empirical performance [6]. [7] accelerates the synthesis of CBF by utilizing Koopman-based matrix multiplications, though at the expense of losing strict guarantees due to operator approximation. [8] constructs control-invariant safe sets from hard constraints via data-driven CBFs, offering efficiency but

J. Liu and E. Mallada are with the Department of Electrical and Computer Engineering, Johns Hopkins University, MD 21218, U.S.A. jliu376@jh.edu, mallada@jhu.edu .

This work was supported by NSF through grant Global Center 2330450, and Johns Hopkins University Institute for Assured Autonomy.

In this paper, we build a framework to trade off the computational complexity of finding safe control sets with the level of conservativeness of the solution, which has theoretical safety guarantees. A key insight of the proposed approach is to substitute the invariance property that Reachability and CBF methods aim to guarantee with a more flexible notion called recurrence [9], [10]. A set is ( τ -) recurrent if every trajectory that leaves the set comes back to it (within τ units of time) infinitely many times. Recurrence has emerged as a practical surrogate for invariance in analysis and verification-e.g., for regions of attraction [11], stability [9], and safety verification [10]. Information-theoretically, enforcing (control) recurrence demands lower data rates than invariance [12] and can often be achieved from finite trajectories [13].

Building on this literature, we extend the notion of Recurrent Barrier Functions proposed in [10] to account for the addition of controls, thus introducing Recurrent Control Barrier Functions (RCBFs). RCBFs relax strict invariance by requiring a finite-time ( τ ) return to a safe set-conditions met by signed distance functions of given sets-while preserving safety as long as the set excludes the τ -backward reachable tube of the unsafe region. We devise a nonparametric, sampling-based procedure to synthesize RCBFs and verify safety quickly and at scale. To do so, we introduce a robust RCBF condition that uses trajectory data to certify a neighborhood of the initial state; an adaptive sampling method and data-driven exploration remove the need for large optimization programs. The method is GPU-friendly and lets practitioners trade conservativeness for computation without compromising safety.

The remainder of this paper is organized as follows. Section II reviews preliminaries on HJ reachability analysis and CBFs. Section III introduces the definition of RCBFs, extending classical CBFs through recurrence-based safety conditions. Section IV develops the robust conditions that allow for data-driven verification of the RCBF property on a neighborhood of trajectory samples. Section V integrates the robust conditions into a sampling-based method for nonparametric safety verification that actively chooses where to sample based on prior outcomes. Section VI provides numerical validations demonstrating the effectiveness of the proposed approach. Section VII concludes the paper and outlines directions for future work.

Notation: ∥· ∥ is an arbitrary norm on R n . For x ∈ R n and r &gt; 0 , the closed ball of radius r centered at x is defined as B r ( x ) := { y ∈ R n | ∥ y -x ∥ ≤ r } . Given a set S ⊆ R n and a point x ∈ R n , the signed distance from x to S is

<!-- formula-not-decoded -->

## II. PRELIMINARIES AND RELATED WORK

## A. Problem Statement

Consider a continuous-time control system:

<!-- formula-not-decoded -->

where x ∈ X ⊆ R n is the system's state in the state space X , u ∈ U ⊆ R m is the control input. We define U ( a,b ] := { u : ( a, b ] → U | u is measurable } , as the set of control signals on the time interval ( a, b ] , and U := U (0 , + ∞ ) . Given u 0 ∈ U (0 ,a ] and u 1 ∈ U (0 ,b ] , their concatenation u 0 u 1 ∈ U (0 ,a + b ] is defined as

<!-- formula-not-decoded -->

Similarly, for u ∈ U ( a,b ] and ( c, d ] ⊂ ( a, b ] we will use u | ( c,d ] to denote the restriction of u to the interval ( c, d ] .

In a more general setting, consider a sequence of control inputs u n ∈ U (0 ,τ n ] , where τ n &gt; 0 for every n ∈ N . We define u [ n ] := u 0 u 1 · · · u n , and u [ ∞ ] := lim n →∞ u [ n ] . At times, we adopt a slight abuse of notation by writing u both for instantaneous inputs in U and for signals in U ( a,b ] ; the intended interpretation will always be clear from context.

Given an initial state x ∈ R n and a control signal u ∈ U (0 ,a ] , we denote by ϕ ( t, x, u ) the trajectory solving (1) for all t ∈ (0 , a ] . Throughout, we impose the following regularity assumptions on (1).

Assumption 1 (Forward Completeness) . The control system (1) is forward complete , that is, for any initial condition x ∈ R n and any input u ∈ U , the solution ϕ ( · , x, u ) exists and is unique on [0 , ∞ ) .

Assumption 2 (Uniform Local Lipschitz Continuity) . The vector field F ( x, u ) in (1) is locally Lipschitz in x , uniformly with respect to u . More precisely, for every compact set S ⊆ R n , there exists a constant L ≥ 0 such that

<!-- formula-not-decoded -->

## B. Safety Assessment

Our goal is finding input signals u ( · ) ∈ U such that the solution ϕ ( t, x, u ) to (1) can avoid an unsafe region X u ⊂ X for all time t ≥ 0 . To that end, we aim to design an algorithm that can quickly find a strict subset of X\X u that achieves this goal. We will therefore say that a state x is considered to be safe if one can find a control u ∈ U such that the state trajectory ϕ ( t, x, u ) does not visit the unsafe region for all future time.

Definition 1 (Safe State) . A state x ∈ X is said to be safe w.r.t. the system (1) if there exists a control u ∈ U such that the trajectory ϕ ( t, x, u ) never visits the unsafe region X u , i.e., ∃ u ∈ U , s.t. ∀ t ≥ 0 , ϕ ( t, x, u ) / ∈ X u .

A common approach to ensure safety according to Definition 1 is to find some set C that does not intersect with X u and has the additional property that trajectories that start in C can be kept in C . That is, C is control invariant.

Definition 2 (Control Invariant Set) . A set C ⊆ X is control invariant w.r.t. (1) if for every x ∈ C , there exists a control u ∈ U such that ϕ ( t, x, u ) ∈ C for all t ≥ 0 .

## C. Reachability Analysis

As mentioned before, a widely adopted method to verify safety is the Hamilton-Jacobi (HJ) reachability analysis. In this framework, one aims to compute the collection of all initial states from which, no matter what control one chooses, the trajectory will eventually end in the unsafe set X u . We provide a formal definition next.

Definition 3 (Backward Reachable Tube) . For a set S , and constant T &gt; 0 , the T -Backward Reachable Tube ( T -BRT) is defined as:

<!-- formula-not-decoded -->

When T = ∞ , we refer to it simply as the Backward Reachable Tube (BRT) and denote by R ( S ) .

To construct the BRT, the HJ reachability procedure casts the safety verification task as an optimal control problem. Here, the controller's objective is to avoid the unsafe set X u . This is quantitatively expressed through a value function V ( x, t ) := min s ∈ [ -t, 0] l ( ϕ ( s, x, u )) , which measures the minimum cost or the distance to entry X u . In the absence of disturbances, the evolution of V ( x, t ) is governed by a Hamilton-Jacobi-Isaacs Variational Inequality that takes the form of a Hamilton-Jacobi-Bellman equation [3]:

<!-- formula-not-decoded -->

where l ( x ) is the terminal condition where V ( x, 0) = l ( x ) , and H ( x, t, ∇ V ( x, t )) := max u ∈ U D x V ( x, t ) · f ( x, u ) .

Once V ( x, T ) is computed, the T -BRT is given by the sublevel set

<!-- formula-not-decoded -->

which implies that any state within this set will eventually lead to X u under any control u ( · ) within less than T units of time. HJ reachability gives rigorous safety guarantees when x ∈ R c + ∞ ( X u ) , which is the largest safe control invariant set, but is computational costly in high dimensions. Efficient solvers for the HJ PDE mitigate this [3], improving practicality. Our work tackles safety from a complementary angle.

## D. Control Barrier Functions

CBFs offer another conservative alternative to HJ reachability. By bounding ˙ h with an extended classK function, they render a chosen set C control invariant and thus ensure safety. To formally introduce CBFs we are required to introduce the notion of extended class K functions.

Definition 4 (Extended Class K Function) . A function κ : R → R is an extended class K function if it is continuous, strictly increasing, and satisfies κ (0) = 0 .

We are now ready to formally introduce CBFs.

Definition 5 (Control Barrier Function [2]) . A continuously differentiable function h ( x ) is a CBF for the system (1) if there exists an extended class K function κ such that,

<!-- formula-not-decoded -->

for all x ∈ X , and where L F h ( x ) = ∂h ∂x ⊤ F ( x, u ) , are firstorder Lie derivatives.

Theorem 1 ( [2]) . An immediate consequence of Definition 5 is that any Lipschitz-continuous controller k ( x ) satisfying

<!-- formula-not-decoded -->

renders the set h ≥ 0 := { x : h ( x ) ≥ 0 } invariant. Thus, h ≥ 0 is, by definition, control invariant.

Thus, if such a CBF h exists and h ≥ 0 ∩X u = ∅ , all states in h ≥ 0 can find a control signal u ∈ U , whose signal at any moment is in the set of k ( x ) . That is to say for any intial state x ∈ h ≥ 0 , there exists u ∈ U such that ϕ ( t, x, u ) ∈ h ≥ 0 , ∀ t &gt; 0 , which means the states in h ≥ 0 are safe [2].

Sum-of-Squares (SOS) programming is widely used to synthesize/verify polynomial CBFs, but its cost grows rapidly with system dimension [14], [15], and polynomials may poorly capture complex safety sets. Neural network CBFs improve expressivity [16], [17], [18], yet their validity is harder to certify due to limited interpretability [18].

## III. RECURRENT CONTROL BARRIER FUNCTION

The core idea behind ensuring safety using traditional CBFs is to construct a scalar function that makes h ≥ 0 control invariant. Such sets can be as computationally expensive as a BRT, making CBF synthesis difficult. Leveraging recurrence, we show this explicit invariant set is unnecessary: valid RCBFs can be built from control recurrent sets , which relax invariance while keeping safety guarantees.

## A. Control Recurrent Sets

In this section, we briefly cover the definition of recurrent sets in a control systems setting, which broadly allow trajectories to leave a set, provided they come back to it. The presentation follows [10], [11], [12], particularly [12].

Definition 6 (Control Recurrent Sets) . A compact set S ⊆ R n is called control recurrent w.r.t. (1) if, for all x ∈ S , ∃ u ∈ U , such that for any t ≥ 0 ,

<!-- formula-not-decoded -->

Likewise, a set S ⊆ R n is called control τ -recurrent ( τ &gt; 0 ) w.r.t. (1) if, for all x ∈ S , ∃ u ∈ U , such that for any t ≥ 0 ,

<!-- formula-not-decoded -->

We refer to such ϕ ( t, x, u ) as a ( τ -)recurrent trajectory.

Fig. 1: Illustration of Recurrent Sets and Recurrent Trajectories

<!-- image -->

As Figure 1 shows, although a τ -recurrent set is not necessarily invariant, it ensures that trajectories starting in S will revisit it within at most τ -time units infinite times. Notably, based on the Definition 6, an invariant set is always τ -recurrent for any τ &gt; 0 . Additionally, a 0-recurrent set is equivalent to an invariant set. Thus, Definition 6 generalizes invariance by allowing the trajectory ϕ ( t, x, u ) to leave the set S before returning [10]. Compared with the invariant sets, recurrent sets show a more flexible shape; it does not need the region to be connected, and it does not require the system (1) to point inwards (or at least not outwards) on all the boundary ∂S .

## B. Recurrent Control Barrier Function

We now move towards introducing the proposed Recurrent Control Barrier Functions. In fact, similar to [10], simply requiring trajectories to return to the set within a finite time, infinitely many times can guarantee the safety for the dynamical system.

Definition 7 (Recurrent Control Barrier Function) . Consider the control system (1) . A continuous function h : R n → R is a Recurrent Control Barrier Function (RCBF) if for all x ∈ D 0 := h ≥-c , with c &gt; 0 , ∃ u ∈ U (0 ,τ ] s.t.

<!-- formula-not-decoded -->

where the function γ : R → R &gt; 0 .

In (5) we follow the standard convention that when the sup is not achieved within the set (0 , τ ] the max is -∞ . Thus, for the max to be lower bounded, it implies that it is achieved within (0 , τ ] . A particular choice of γ that will be of use throughout this paper is

<!-- formula-not-decoded -->

where α and β are positive parameters. This will be particularly useful in our converse results in Section III-C.

The following theorem describes how to use RCBFs to assess safety.

Theorem 2 (Safety Assessment via RCBFs) . Let h be an RCBF as in Definition 7. Then:

- (i) The superlevel set h ≥ 0 is control τ -recurrent, i.e., for any x ∈ h ≥ 0 there exists u ∈ U such that the trajectory ϕ ( t, x, u ) always returns to h ≥ 0 within time τ .

Moreover, if h ≥ 0 ∩ R τ ( X u ) = ∅ , then:

In particular, under the condition h ≥ 0 ∩ R τ ( X u ) = ∅ , the set h ≥ 0 is safe.

- (ii) For any x ∈ h ≥ 0 , every u ∈ U that renders ϕ ( t, x, u ) τ -recurrent also ensures that ϕ ( t, x, u ) / ∈ X u for all t ≥ 0 .

Proof. (i) Control τ -recurrence of h ≥ 0 . Given x ∈ h ≥ 0 , fix x 0 := x and t 0 := 0 . By the RCBF condition (5), there exists u 0 ∈ U (0 ,τ ] and a time

<!-- formula-not-decoded -->

such that x 1 := ϕ ( τ 0 , x 0 , u 0 ) ∈ h ≥ 0 and t 1 := τ 0 + t 0 . Proceed inductively: given x n ∈ h ≥ 0 and t n , use (5) to select u n ∈ U (0 ,τ ] and τ n ∈ (0 , τ ] as in (7), leading to x n +1 := ϕ ( τ n , x n , u n ) ∈ h ≥ 0 , and t n +1 = τ n + t n .

The desired control u ∈ U is thus defined by concatenating the restrictions of u n to the intervals (0 , τ n ] , i.e.,

<!-- formula-not-decoded -->

and letting u = lim n →∞ u [ n ] ∈ U (0 ,t ∗ ] , where t ∗ = lim n →∞ t n . An argument similar to [9, Lemma 1] shows that t ∗ = ∞ . Moreover, it follows from the construction that for all n ≥ 0 ,

<!-- formula-not-decoded -->

and therefore ϕ ( t n , x, u ) ∈ h ≥ 0 . It follows then from the fact that for all n ≥ 0 , x n ∈ h ≥ 0 , t n +1 -t n ∈ (0 , τ ] and t n → ∞ , that the trajectory ϕ ( t, x, u ) is τ -recurrent w.r.t. h ≥ 0 . Since x ∈ h ≥ 0 was chosen arbitrarily, ( i ) follows.

<!-- formula-not-decoded -->

(ii) Safety under h ≥ 0 ∩ R τ ( X u ) = ∅ . Assume h ≥ 0 ∩ R τ ( X u ) = ∅ . Take any x ∈ h ≥ 0 and any control u ∈ U that renders ϕ ( t, x, u ) τ -recurrent w.r.t. h ≥ 0 . Suppose, towards a contradiction, that the trajectory is unsafe: there exists t ′ &gt; 0 with ϕ ( t ′ , x, u ) ∈ X u . Since h ( x ) ≥ 0 and h &lt; 0 on X u , by continuity there exists a last exit time t ′′ ∈ [0 , t ′ ] with h ( ϕ ( t ′′ , x, u )) = 0 and h ( ϕ ( t, x, u )) &lt; 0 for all t ∈ ( t ′′ , t ′ ] . Because h ≥ 0 ∩ R τ ( X u ) = ∅ , the state ϕ ( t ′′ , x, u ) cannot reach X u within time τ , hence t ′ -t ′′ &gt; τ and which contradicts with the fact that u renders ϕ ( t, x, u ) τ -recurrent w.r.t. h ≥ 0 .

Besides ensuring safety, RCBFs also share similar properties like standard CBFs. In particular, it is possible to show that whenever x ∈ D 0 \ h ≥ 0 , there is always some u ∈ U such that

<!-- formula-not-decoded -->

with d ( S, x ) := min y ∈ S ∥ y -x ∥ , thus ensuring that trajectories come back to h ≥ 0 under simplified condition. We do not make these claims formal here, and refer the reader to [10] for similar arguments.

## C. Signed Distance Function: a Valid RCBF

In this section, we present a striking result. The existence of a CBF h satisfying some regularity conditions is sufficient for synthesizing a simple sign distance function that satisfies our RCBF condition. Firstly, we require h to be sector contained.

Definition 8 (Sector Containment) . Let h : D ⊆ R n → R be continuous. If ∃ a 1 , a 2 &gt; 0 such that

<!-- formula-not-decoded -->

for all x ∈ D , we say that h is sector contained.

The second condition refers to the particular choice of extended class K function. In particular, we will consider the sub-class:

<!-- formula-not-decoded -->

Theorem 3 (Validity of Signed Distance Function as RCBF) . Let h be a CBF satisfying (2) and (9) over D 0 := h ≥-c with parameters c &gt; 0 and a 2 &gt; a 1 &gt; 0 , and extended class K function κ α,β as in (10) , with parameters α &gt; 0 and β &gt; 0 . Then, for any closed set S satisfying h ≥ 0 ⊆ S ⊆ h ≥-c , with ∂S ∩ h =0 = ∅ , the function

<!-- formula-not-decoded -->

is an RCBF over ˆ D 0 := ˆ h ≥-ˆ c where ˆ c ≥ 0 is the largest constant satisfying ˆ h ≥-ˆ c ⊆ h ≥-c .

Precisely, for all x ∈ ˆ h ≥-ˆ c , there exists u ∈ U (0 ,τ ] s.t.

<!-- formula-not-decoded -->

where ˆ γ := γ ˆ α, ˆ β , with ˆ α, ˆ β &gt; 0 satisfying ˆ α &gt; α, ˆ β &lt; β , and ˆ τ ≥ max { log( a 2 /a 1 ) ˆ α -α , log( a 2 /a 1 ) β -ˆ β } + log( δ/δ ) min { ˆ α, ˆ β } where δ := sup x ∈ D 0 (sd( x, S ) -sd( x, h ≥ 0 )) , δ := inf x ∈ D 0 (sd( x, S ) -sd( x, h ≥ 0 )) .

Proof. The proof follows closely similar results for the noncontrol case [10, Theorem 11] and it is omitted due to space constraints.

## IV. SAFETY ENFORCEMENT USING RECURRENCE

In this section, we aim to develop robust conditions that leverage trajectory samples to certify the satisfaction of the RCBF condition on a neighborhood of the trajectory. The proposed approach reduced the problem of checking the RCBF condition on uncountably many points, to checking it on finitely many states, possibly in parallel.

## A. Verification of a Cell

To proceed, we first analyze how trajectories deviate from one another. This step lays the foundation for constructing a stronger verification criterion that ensures local safety in a neighborhood B r ( x ) of each sampled point x , which we refer here as a cell.

Lemma 1. Suppose that two trajectories ϕ ( t, x, u ) , ϕ ( t, y, u ) starts from x and y respectively and share the same control input u all the times, where ∥ x -y ∥ ≤ r . Then we have:

<!-- formula-not-decoded -->

where L is a uniform bound on the Lipschitz constant of (1) on the x variable.

<!-- formula-not-decoded -->

We leverage Lemma 1 to verify different properties of a given cell B r ( · ) . In particular, Theorem 4 below gives us a condition that verifies whether a cell B r ( x ) is completely inside R τ ( X u ) , completely outside R τ ( X u ) , or partially inside R τ ( X u ) . This will be critical to over approximate R τ ( X u ) .

Theorem 4. Consider a state x ∈ X , and let B r ( x ) := { y |∥ y -x ∥ ≤ r } be a neighborhood of x . Then, we have: (i) Given x ∈ X , if there exists u ∈ U (0 ,τ ] s.t.

<!-- formula-not-decoded -->

for some r &gt; 0 , then B r ( x ) ∩ R τ ( X u ) = ∅ ,

<!-- formula-not-decoded -->

- (ii) Conversely, given x ∈ X , if for all u ∈ U (0 ,τ ] ,

Proof. (i) If the initial states satisfy the condition (13), then by Lemma 1, we have:

sd( ϕ ( t, y, u ) , X u ) ≥ sd( ϕ ( t, x, u ) , X u ) -re -Lt &gt; 0 , for all t ∈ [0 , τ ] and all y ∈ B r ( x ) . Hence, B r ( x ) ∩ R τ ( X u ) = ∅ .

(ii) If instead the initial states satisfy the condition (14), let t ∗ &lt; τ be the time at which

<!-- formula-not-decoded -->

Again, by Lemma 1, we have:

<!-- formula-not-decoded -->

for all y ∈ B r ( x ) . Consequently,

<!-- formula-not-decoded -->

The following theorem verifies whether the states of a cell all satisfy the RCBF condition (5) or all such states are guaranteed not to satisfy such a condition.

Theorem 5. Given a closed set S , a candidate RCBF h ( · ) := -sd( · , S ) , and function γ := γ α,β , with α, β &gt; 0 . (i) Let

<!-- formula-not-decoded -->

and assume that ∃ u ∈ U (0 ,τ ] s.t. the following holds

<!-- formula-not-decoded -->

for some r &gt; 0 . Then for all y ∈ B r ( x ) , the RCBF condition is satisfied, i.e.,

<!-- formula-not-decoded -->

(ii) Let

<!-- formula-not-decoded -->

and assume that ∀ u ∈ U (0 ,τ ] s.t. the following holds

<!-- formula-not-decoded -->

for some r &gt; 0 . Then, for all y ∈ B r ( x ) , the RCBF condition is not satisfied, i.e.,

<!-- formula-not-decoded -->

Proof. (i) Let t ∗ and u ∗ be the time that maximizes the left-hand side of (16), i.e.

<!-- formula-not-decoded -->

At this maximizing time t ∗ ∈ (0 , τ ] , it follows that

<!-- formula-not-decoded -->

where the first inequality follows from the definition of maximum, the second and fourth inequalities are derived from Lemma 1 and the third inequality is derived from the conditions of (17).

- (ii) Let t ∗ and u ∗ be the time and control signal that maximize the left-hand side of (20), i.e.

<!-- formula-not-decoded -->

Again, at this maximizing time t ∗ ∈ (0 , τ ] , we get

<!-- formula-not-decoded -->

where the second inequality is derived from the definition of the maximum, the first and fourth inequalities are derived from Lemma 1, and the third inequality is derived from the conditions of (19).

## V. NUMERICAL METHODS

̸

This verification process is carried out in three stages, as illustrated in Algorithm 1, where lines 2 , 3 , and 4 represent stages 1 , 2 , and 3 , respectively.

Building on Theorem 4 and Theorem 5, we propose a safety verification algorithm aimed at finding a set S ⊂ X such that h = -sd( x, S ) satisfies all the necessary properties for safety assessment described in Theorem 2. The proposed method adaptively partitions X into cells G := { g i := B r i ( x i ) } |G| i =1 , such that g i ∩ g j = ∅ , i = j and ∪G := ∪ |G| i =1 g i = X , when running our algorithms, two disjoint lists, G s (tentative safe cells) and G u (verified unsafe cells) are maintained and refined, and progressively, cells from G s are assigned to G u (while keeping X = ( ∪G u ) ∪ ( ∪G s ) ) until one is able to guarantee that the safe set S = ∪G s and RCBF h = -sd( x, S ) satisfy the robust conditions of Theorem 2.

## Algorithm 1 VerifyRegion( X , τ , α , β )

- 2: G s , G u = VerifyCells( X , X u , 0 , (13) , (14) )
- 1: Input: State Space X , Parameters τ , α , and β &gt; 0 .
- 3: G s , G u = VerifyCells( G s , G u , τ, (13) , (14) )
- 4: G s , G u = VerifyCells( G s , G u , τ, (17) , (20) ) ▷ α and β are used in the conditions (17) and (20).
- 5: return G s , G u

Each stage aims to sequentially get a better approximation of a region S ⊆ X for h = -sd( x, S ) to be a valid RCBF. Stage 1 first finds a sufficiently fine outer approximation of X u . Stage 2 finds an outer approximation of R τ ( ∪G u ) , with G u being the output of Stage 1. Finally, Stage 3 further uses S = ∪G s in order to find such a h satisfy the RCBF condition.

All stages are implemented by calling a VerifyCells routine, Algorithm 2, with the current estimates of G s and G u and the assignment conditions C s and C u , corresponding to conditions (13) and (17), and (14) and 20, respectively. Note that we initially start with one cell (the full set X ), and each pass progressively finds finer and more accurate approximations for G s and G u .

## Algorithm 2 VerifyCells( G , G u , τ, C s , C u )

- 2: while G ̸ = ∅ do
- 1: Input: Grid G and G u , Parameter τ ≥ 0 , Robust Safe Condition C s , and Robust Unsafe Condition C u .
- 3: for g = ( x ) , i N for some r and x do
- 4: G ← G - { g i
- ∀ i B r ∈ G ∈ }
- 6: end for
- 5: G , G s , G u = SafetyCheck( g i , G , G u , τ, C s , C u )
- 7: end while
- 8: return G s , G u

The verification process in Algorithm 2 can be done in parallel for all cells in the input G and ends when this set is empty. This framework facilitates high parallelism through concurrent cell verification while ensuring rigorous safety guarantees. That is to say, each cell in Algorithm 2 is eventually verified to be safe or declared to be unsafe by employing the safe and unsafe assignment conditions, C s and C u , corresponding to each stage. The specific verification of each cell is implemented by routines SafetyCheck (Algorithm 3).

## Algorithm 3 SafetyCheck( g i , G , G u , τ, C s , C u )

- 2: X u = G u
- 1: Input: Cell g i to check; Grids G , G s , G u ; Parameter τ &gt; 0 ; Robust Safe Condition C s ; Robust Unsafe Condition C u .
- 3: G s = ∅
- 4: Sample n s trajectories of length τ from a representative point in g i
- 5: if all sampled trajectories satisfy C u then
- 7: else if at least one sampled trajectory satisfies C s then
- 6: G u ←G u ∪ { g i }
- 8: G s ←G s ∪ { g i }
- 9: else
- 10: G ← G ∪ SplitCell( g i )
- 11: end if
- 12: return G , G s , G u

Notably, to verify stages 2 and 3, each cell is required to sample n s trajectories of length τ and check whether all satisfy an unsafe condition or at least one satisfies the safe condition. Finally, in cases where neither safe nor unsafe conditions can be verified, one is required to either increase the resolution via the SplitCell routine (Algorithm 4) or eventually declare the cell to be unsafe when the resolution is met.

## Algorithm 4 SplitCell( g )

- 1: Input: Grid cell g = B r ( x ) ∈ G
- 2: Let ( x 1 , x 2 , . . . , x n ) = x
- 3: P := { x + 2 r 3 · δ | δ ∈ {-1 , 0 , 1 } n }
- 4: return G split := {B r 3 ( p ) | p ∈ P }

## VI. NUMERICAL SIMULATIONS

In this section, we validate the performance and the safety of our algorithm using a 3D evasion problem:

<!-- formula-not-decoded -->

with [ x 1 , x 2 ] T ∈ R 2 representing the relative planar location and x 3 ∈ [0 , 2 π ] the relative direction. v ≥ 0 is the aircraft velocity and u ∈ [ -1 , 1] is the evader's angular velocity. A collision occurs if √ x 2 1 + x 2 2 ≤ 1 , which defines a cylindrical collision set of radius 1 along the x 3 -axis. Our goal is to determine the set of initial states that inevitably lead to a collision, regardless of the evader's actions.

## A. Results Comparison

We use τ = 1 s and a total number of control samples per cell n s = 3000 . V BRT denotes the unsafe region volume computed via HJ reachability at r min = 0 . 041 (the grid resolution). We calculate the intersection ratio ( V BRT ∩ h ′ ≤ 0 /V BRT ) between our method ( β = α = 0 . 05 ) and HJ solutions at different precisions. As shown in Table I and Figure 2, low-precision HJ analysis underestimates unsafe regions, risking safety misjudgment. Our method guarantees complete containment of true unsafe regions at all precisions.

TABLE I: Comparison of the Fraction of the Unsafe Zone Volume Captured by Different Methods at Different Precision

| Methods \ r min   | 1.111       | 0.370       | 0.123       | 0.041   |
|-------------------|-------------|-------------|-------------|---------|
| HJ BRT [19]       | 0.510 ( ✗ ) | 0.900 ( ✗ ) | 0.953 ( ✗ ) | 1 ( ✓ ) |
| Recurrent Set     | 1 ( ✓ )     | 1 ( ✓ )     | 1 ( ✓ )     | 1 ( ✓ ) |

Beyond safety guarantees, Table II demonstrates our method's faster computation time at high precision through parallelization.

TABLE II: Comparison of Computation Time between HJ reachability and Recurrent Set Approximation under Different Precision, τ = 1 s, α = 1 , n s = 3000

| Method \ r min   | 1.111        | 0.370        | 0.123        | 0.041         |
|------------------|--------------|--------------|--------------|---------------|
| HJ BRT [19]      | 0.02 s ( ✗ ) | 0.19 s ( ✗ ) | 2.33 s ( ✗ ) | 83.73 s ( ✓ ) |
| Recurrent Set    | 0.13 s ( ✓ ) | 0.61 s ( ✓ ) | 3.19 s ( ✓ ) | 19.75 s ( ✓ ) |

Fig. 2: Contour Plot of the Boundary of the Unsafe Region with Different Precision and Different Methods when x 3 = π

<!-- image -->

## B. Ablation Study

Definition 6 shows the recurrent set converges to the invariant set as τ → 0 . To gauge parameter effects on RCBF performance, we ran a sweep over two metrics: the normalized volume gap ( V τ -V BRT ) /V BRT and computation time t . Figure 3 indicates an inverse τ -accuracy trade-off: smaller τ reduces the volume gap but drives computation time up (roughly exponentially). Nonetheless, runtimes remain practical and safety is preserved for all tested parameters.

Fig. 3: Volume gap and computation time versus τ (and α ); n s =3000 , r min =0 . 370 .

<!-- image -->

## VII. CONCLUSION AND DISCUSSION

We introduced Recurrent Control Barrier Functions (RCBFs), generalizing CBFs by enforcing finite-time ( τ ) return rather than strict invariance. We proved that the signed distance to a τ -recurrent set is a valid RCBF, yielding rigorous safety guarantees. A sampling-based algorithm approximates the safe region. Simulations demonstrate provably safe, though over-approximated, sets with competitive computational performance.

An approximation gap persists between computed and true safe sets. While denser sampling improves accuracy, the precise link between sampling parameters and error remains open. Future work will quantify this relationship and develop corresponding models to guide adaptive sampling for tighter guarantees.

## REFERENCES

- [1] I. M. Mitchell, A. M. Bayen, and C. J. Tomlin, 'A timedependent hamilton-jacobi formulation of reachable sets for continuous dynamic games,' IEEE Transactions on automatic control , vol. 50, no. 7, pp. 947-957, 2005.
- [2] A. D. Ames, S. Coogan, M. Egerstedt, G. Notomista, K. Sreenath, and P. Tabuada, 'Control barrier functions: Theory and applications,' in 2019 18th European control conference (ECC) , IEEE, 2019, pp. 3420-3431.
- [3] S. Bansal, M. Chen, S. Herbert, and C. J. Tomlin, 'Hamiltonjacobi reachability: A brief overview and recent advances,' in 2017 IEEE 56th Annual Conference on Decision and Control (CDC) , IEEE, 2017, pp. 2242-2253.
- [4] H. Dai and F. Permenter, 'Convex synthesis and verification of control-lyapunov and barrier functions with input constraints,' in 2023 American Control Conference (ACC) , IEEE, 2023, pp. 4116-4123.
- [5] A. Clark, 'Verification and synthesis of control barrier functions,' in 2021 60th IEEE Conference on Decision and Control (CDC) , IEEE, 2021, pp. 6105-6112.
- [6] S. Bansal and C. J. Tomlin, 'Deepreach: A deep learning approach to high-dimensional reachability,' in 2021 IEEE International Conference on Robotics and Automation (ICRA) , IEEE, 2021, pp. 1817-1824.
- [7] C. Folkestad, Y. Chen, A. D. Ames, and J. W. Burdick, 'Data-driven safety-critical control: Synthesizing control barrier functions with koopman operators,' IEEE Control Systems Letters , vol. 5, no. 6, pp. 2012-2017, 2020.
- [8] J. Lee, J. Kim, and A. D. Ames, 'A data-driven method for safety-critical control: Designing control barrier functions from state constraints,' in 2024 American Control Conference (ACC) , IEEE, 2024, pp. 394-401.
- [9] R. Siegelmann, Y. Shen, F. Paganini, and E. Mallada, 'A recurrence-based direct method for stability analysis and gpu-based verification of non-monotonic lyapunov functions,' in 62nd IEEE Conference on Decision and Control (CDC) , IEEE, Dec. 2023, pp. 6665-6672.
- [10] Y. Shen, H. Sibai, and E. Mallada, 'Generalized barrier functions: Integral conditions &amp; recurrent relaxations,' in 60th Allerton Conference on Communication, Control, and Computing , Sep. 2024, pp. 1-8.
- [11] Y. Shen, M. Bichuch, and E. Mallada, 'Model-free learning of regions of attraction via recurrent sets,' in 61st IEEE Conference on Decision and Control (CDC) , Dec. 2022, pp. 4714-4719.
- [12] H. Sibai and E. Mallada, 'Recurrence of nonlinear control systems: Entropy and bit rates,' in Proceedings of the 27th ACM International Conference on Hybrid Systems: Computation and Control (HSCC) , ser. HSCC '24, New York, NY, USA: Association for Computing Machinery, May 2024, pp. 1-9.
- [13] H. Sibai and E. Mallada, 'Recurrence of nonlinear control systems: Entropy, bit rates, and finite alphabets,' in Nonlinear Analysis: Hybrid Systems , Feb. 2025, pp. 1-16, submitted.
- [14] A. Clark, 'A semi-algebraic framework for verification and synthesis of control barrier functions,' IEEE Transactions on Automatic Control , 2024.
- [15] S. Prajna and A. Jadbabaie, 'Safety verification of hybrid systems using barrier certificates,' in International Workshop on Hybrid Systems: Computation and Control , Springer, 2004, pp. 477-492.
- [16] W. Xiao et al., 'Barriernet: Differentiable control barrier functions for learning of safe robot control,' IEEE Transactions on Robotics , vol. 39, no. 3, pp. 2289-2307, 2023.
- [17] S. Liu, C. Liu, and J. Dolan, 'Safe control under input limits with neural control barrier functions,' in Conference on Robot Learning , PMLR, 2023, pp. 1970-1980.
- [18] O. So et al., 'How to train your neural control barrier function: Learning safety filters for complex inputconstrained systems,' in 2024 IEEE International Conference on Robotics and Automation (ICRA) , IEEE, 2024, pp. 11 532-11 539.
- [19] StanfordASL, Hj reachability: Hamilton-jacobi reachability analysis in jax , https : / / github . com / StanfordASL/hj\_reachability , 2024.
- [20] F. Bullo, Contraction Theory for Dynamical Systems , 1.2. Kindle Direct Publishing, 2024, ISBN: 979-8836646806.

## APPENDIX

## A. Proof of Lemma 1

Proof. According to the assumption of system (1), since the system (1) is uniformly continuous in u , thus L u = max t ∈ (0 ,τ ] ∥ g ( ϕ ( t, x, u )) ∥ := max ∥ v ∥ =1 ,t ∈ (0 ,τ ] ∥ g ( ϕ ( t, x, u )) v ∥ &gt; 0 exists. And the system (1) is uniformly continuous in u , and Lipschitz continuous in x for fixed control u , with a little abuse of the notation, for all the states x ′ and y ′ in trajectories ϕ ( t, x, u ) and ϕ ( t, y, u ) , ∀ t ∈ (0 , τ ] we have:

<!-- formula-not-decoded -->

Thus, according to Corollary 3.17 and Gr¨ onwall Comparison Lemma in [20], we have:

<!-- formula-not-decoded -->

where equality is held because two trajectories have the same input trajectory.

Suppose x ∗ = arg min x ∗ ∈ ∂S sd( ϕ ( t, x, u ) , S ) , y ∗ = arg min y ∗ ∈ ∂S sd( ϕ ( t, y, u ) , S ) . The three cases are analyzed as follows:

Case 1 : ϕ ( t, x, u ) and ϕ ( t, y, u ) are both in S , and then we have

<!-- formula-not-decoded -->

where the first equality follows from the definition, and the first inequality follows from the triangle inequality.

Case 2 : ϕ ( t, x, u ) and ϕ ( t, y, u ) are both not in S , and then with the same reason, similarly, we have

<!-- formula-not-decoded -->

Case 3 : One of ϕ ( t, x, u ) and ϕ ( t, y, u ) is in S and the other not in S . Without loss of generality, we can assume that ϕ ( t, x, u ) is in S and ϕ ( t, y, u ) is not in S . Then there at least exists a λ ∈ [0 , 1] such that λϕ ( t, x, u ) + (1 -λ ) ϕ ( t, y, u ) ∈ ∂S and we denote p ∗ := λϕ ( t, x, u )+(1 -λ ) ϕ ( t, y, u ) ∈ ∂S , thus, we have

<!-- formula-not-decoded -->

where the first equality and the first inequality follow from the definition of the signed distance function, and the second equality follows from the definition of p ∗ . In all cases, we obtain | sd( ϕ ( t, x, u ) , S ) -sd( ϕ ( t, y, u ) , S ) | ≤ re Lt as required.