## Computing Safe Control Inputs using Discrete-Time Matrix Control Barrier Functions via Convex Optimization

James Usevitch, Juan Augusto Paredes Salazar, and Ankit Goel

Abstract -Control barrier functions (CBFs) have seen widespread success in providing forward invariance and safety guarantees for dynamical control systems. The majority of formulations consider continuous-time formulations, but recent focus has shifted to discrete-time dynamics. A crucial limitation of discrete-time formulations is that CBFs that are nonconcave in their argument require the solution of nonconvex optimization problems to compute safety-preserving control inputs, which inhibits real-time computation of control inputs guaranteeing forward invariance. This paper presents a novel method for computing safety-preserving control inputs for discretetime systems with nonconvex safety sets, utilizing convex optimization and the recently developed class of matrix control barrier function techniques. The efficacy of our methods is demonstrated through numerical simulations on a bicopter system.

## I. INTRODUCTION

Guaranteeing safety and collision avoidance for dynamical systems is a fundamental problem in control theory and robotics. Control barrier functions (CBFs) have become a widely applied technique to obtain safety guarantees for systems with applications in aerospace [1], [2], robotics [3], [4], self-driving cars [5], [6], and numerous other domains [7]. The majority of prior work on CBFs has considered continuous-time systems, but a growing body of work has analyzed CBFs from a discrete-time perspective [8]-[12].

One key challenge of discrete-time CBFs is that the optimization formulation for computing a safetypreserving control input is generally nonconvex. Unlike continuous-time CBFs, the safety constraint is, in general, non-affine in the control input; therefore, the convexity of the optimization problem heavily depends on the form of the function defining the safe set. Many common collision avoidance scenarios require the use of nonconvex safe set functions, which necessitate the use of nonconvex optimization solvers that have longer runtimes and give few, if any, guarantees on finding a globally optimal solution.

James Usevitch is with the Department of Electrical and Computer Engineering, Brigham Young University, Provo, UT 84602. james usevitch@byu.edu

Juan Augusto Paredes Salazar and Ankit Goel are with the Department of Mechanical Engineering, University of Maryland, Baltimore County,1000 Hilltop Circle, Baltimore, MD 21250. japarede, ankgoel@umbc.edu

Fig. 1: Illustration of our proposed method to maintain convexity of computing safe control inputs for discrete-time systems. (A): The current state is projected onto the unsafe set. (B): A halfspace is formed which excludes the obstacle, and a control input keeping the next state in the halfspace is computed. (C): The process is repeated iteratively. (D): The proposed method can be applied to scenarios where the unsafe set is a subset of a union of convex regions.

<!-- image -->

Prior work has dealt with this challenge in several ways. In [8], the authors considered linear systems and convex quadratic discrete-time CBFs to maintain convexity of the optimization program computing safe control inputs. The authors of [9], [10], [13] assume that the composition of the CBF with the dynamics is concave in the control input. This results in a convex optimization problem; however, the assumption does not hold for many common collision avoidance scenarios involving convex obstacles. In [12], the notion of partially affine CBFs was introduced, which guarantees convexity of the optimization problem under a specific form of partitioned control-affine discrete-time dynamics. Despite the progress made by these prior works, the challenge of computing safe control inputs for discretetime systems using solely convex optimization remains an open problem.

In addition, prior work has only considered scalarvalued control barrier functions. Recently, the notion of continuous-time matrix control barrier functions (MCBFs) was introduced [14], [15]. MCBFs, of which scalar-valued CBFs are a special case, allow for more general classes of constraints over the cone of positive semidefinite matrices using the Loewner order. To our knowledge, the notion of MCBFs has not been extended to discrete-time dynamics.

This paper introduces the concept of exponential discrete-time matrix control barrier functions and presents a novel method for computing safe control inputs using solely convex optimization tools. Our proposed method operates by iteratively constructing convex subsets of the safe set obtained through a projectionbased method. The method only requires solving two sequential convex optimization problems, and our experimental results suggest that the method is considerably faster and more reliable than nonconvex optimization approaches. The main contributions of this work thus are

- A novel definition of exponential discrete-time matrix control barrier functions,
- A novel method to compute safe control inputs for discrete-time systems with nonconvex safe sets using solely convex optimization. This includes the new notions of safe subset functions and Subsetbased Discrete-Time Exponential Matrix Control Barrier Functions (SDTE-MCBFs).
- A novel extension of indefinite matrix safe sets to discrete-time matrix control barrier functions

We note that the work [11] considers a method of projecting onto convex obstacles, similar to the one presented in this paper. However, this prior work only considers the special case of scalar-valued safe set functions, does not consider the zeroing CBF property of asymptotic convergence to the safe set, and does not consider disjunctive boolean compositions of multiple CBFs.

The outline of this paper is as follows: notation and the problem formulation are given in Section II. Our main results are given in Section III. Numerical simulations demonstrating the efficacy of our proposed method are given in IV. A brief conclusion is given in Section V.

## II. NOTATION AND PROBLEM FORMULATION

The closure of a set S is denoted cl ( S ) , the convex hull is denoted co ( S ) , and the power set is denoted 2 S . The set of symmetric real matrices of size p × p is denoted S p . The cone of positive semidefinite symmetric p × p matrices is denoted S p + , and the set of positive definite p × p symmetric matrices is denoted S p ++ . Given matrices A,B ∈ R n × n , the notation A ⪰ 0 and B ≻ 0 indicate that A is positive semidefinite and B is positive definite as per the Loewner order.

The following theorem will be used to bound the eigenvalues of the matrices in S p .

Theorem 1 (Weyl's Inequality [16, Thm 4.3.1]) . Let A,B ∈ S p . Let the respective eigenvalues of A,B and A + B be { λ i ( A ) } p i =1 , { λ i ( B ) } p i =1 , and { λ i ( A + B ) } p i =1 . Let the eigenvalues be ordered such that λ 1 ≤ λ 2 ≤ · · · ≤ λ p . Then the following holds:

<!-- formula-not-decoded -->

The following will be required for our analysis of convex sets.

Definition 1 (Projection Mapping) . Given a closed, convex set C ⊂ R n , the projection mapping P C : R n → R n is defined as P C ( x ) = arg min z ∈ C ∥ z -x ∥ .

Definition 2 (Normal Cone [17]) . The normal cone mapping of a convex set C ⊂ R n , denoted N C : R n → 2 R n is defined as N C ( x ) ≜ { v ∈ R n : v ⊺ ( z -x ) ≤ 0 for all z ∈ C } .

Theorem 2 ([17, Prop. 6.17]) . Given a convex set C ⊂ R n , the normal cone mapping N C and projection mapping P C are related as follows, where I indicates the identity mapping:

<!-- formula-not-decoded -->

A. Background on Discrete-Time Safety Filters

Consider a discrete-time dynamical system with the control-affine form

<!-- formula-not-decoded -->

Here, x k ∈ R n denotes the state at step k , u ∈ R m denotes the control input at step k , and the functions f : R n → R n and g : R n → R n × m are locally Lipschitz in their arguments. Without loss of generality, we assume an initial step value of k = 0 .

The state space R n is divided into a safe set S h ⊂ R n and an unsafe set S h = R n \ S h . The set S h is defined as the superlevel sets of a function h : R n → R as follows:

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

The objective is to render the set S h forward invariant with respect to the dynamics (3), which is defined as follows:

Definition 3. A set C ⊂ R n is forward invariant with respect to the dynamics (3) if x k ∈ C for all k ≥ 0 . The set C is called safe if it is both forward invariant and C ⊆ S h .

Let D h ⊆ R n be a domain such that S h ⊂ int ( D h ) . It has been shown in prior literature that satisfaction of the following condition for all x k ∈ D h is sufficient to ensure forward invariance of the set S h [8]:

<!-- formula-not-decoded -->

where 0 &lt; γ ≤ 1 .

Definition 4. A function h : R n → R is called a discrete-time exponential control barrier function for the system (3) if the condition (5) holds for all x ∈ D h .

We define the set

<!-- formula-not-decoded -->

Theorem 3 ([8]) . Suppose that (5) holds for all x k ∈ D h and h ( x 0 ) ≥ 0 . Then any control law u k ( · ) such that u k ( x k ) ∈ K h ( x k ) renders the set S h forward invariant.

In words, K h is the set of control inputs that render the set S h forward invariant. A control input u k ∈ K h ( x k ) is called safe . It is also straightforward to show that control inputs K h also render the set S exponentially stable in D h .

Suppose a nominal feedback control law u nom ( · ) is given for system (3) above. Suppose that several discrete-time CBFs { h i ( x k ) } i =1 ,...,M are given. If the condition (5) holds for all h i , a safe control input u ∗ ( x k ) ∈ K h ( x k ) that minimally modifies u nom in the sense of the Euclidean norm can be computed via the following (possibly nonconvex) optimization problem:

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

Several limitations exist to this notion of discrete-time control barrier function and safety filtering as presented above. First, observe that the constraints in (7b) are convex if and only if each h i ( · ) is concave in its argument. 1 If any h i ( · ) is nonconcave, then the entire optimization problem (7) is nonconvex. This can inhibit real-time computation of the control input u ∗ ( x k ) on control systems.

In addition, the formulation (7) is unable to represent more complex semidefinite matrix constraints, including constraints on matrix eigenvalues and safe sets in the form of spectrahedra. The recent work [14] introduces the notion of matrix control barrier functions to address

1 Recall that the composition of a function concave (convex) in its argument h ( · ) with an affine mapping u ↦→ f ( x k ) + g ( x k ) u is likewise concave (convex) [18, Sec. 3.2.2].

this gap. More specifically, given a matrix valued function H : R n → S p , they consider safe sets of the form

<!-- formula-not-decoded -->

However, [14] considers only continuous-time dynamical systems. Conditions to render sets of the form S forward invariant for discrete-time systems have not been considered in the literature.

This paper presents novel methods to address both of these gaps. Our methods are applicable to matrix-valued safe sets of the form (8), of which the scalar-valued safe sets of the form (4) are a special case. The problem addressed by this paper is as follows:

Problem II.1. Given the discrete-time dynamics (3), derive a method to compute control inputs u k rendering sets of the form in (8) forward invariant using solely convex optimization methods.

## III. MAIN RESULTS

## A. Discrete-Time Exponential Matrix Control Barrier Functions

We consider safe sets S of the form (8). The following result presents a discrete-time condition under which the set S is rendered forward invariant.

Lemma III.1. Consider the dynamics (3) and the set S in (8). Let D ⊃ S be an open superset of S . The set S is forward invariant if there exists a constant 0 &lt; γ ≤ 1 such that the following condition holds for all x ∈ D :

<!-- formula-not-decoded -->

Proof. We proceed by induction. By the definition of forward invariance, assume that x 0 ∈ S . This implies that H ( x 0 ) ⪰ 0 . Observe that (9) can be rewritten as

<!-- formula-not-decoded -->

Since 0 &lt; γ ≤ 1 , the matrix (1 -γ ) H ( x 0 ) is positive semidefinite. Equation (10) implies that H ( x 1 ) is therefore positive semidefinite. This can be seen by noting from (10) that H ( x 1 ) -(1 -γ ) H ( x 0 ) ⪰ 0 = ⇒ y ⊺ ( H ( x 1 ) -(1 -γ ) H ( x 0 )) y ≥ 0 for all y ∈ R p , implying that y ⊺ H ( x 1 ) y ≥ y T (1 -γ ) H ( x 0 ) y ≥ 0 since (1 -γ ) H ( x 0 ) is positive semidefinite. It follows that H ( x 1 ) ⪰ 0 . Now assume that H ( x k ) is positive semidefinite for any k ≥ 0 . This implies that (1 -γ ) H ( x k ) is also positive semidefinite. Similar arguments can be used to conclude that H ( x k +1 ) ⪰ 0 , which concludes the proof.

Definition 5. A function H : R n → S p is called an discrete-time exponential matrix control barrier function

(DTE-MCBF) for the system (3) if there exists a constant 0 &lt; γ ≤ 1 and a domain D ⊃ S such that for all x ∈ D there exists a u ∈ R m satisfying

<!-- formula-not-decoded -->

We define the set of safety-preserving control inputs K H : R n → 2 R m as

<!-- formula-not-decoded -->

Let the eigenvalues of H ( x k ) be ordered as λ 1 ( x k ) ≤ λ 2 ( x k ) ≤ · · · ≤ λ p ( x k ) . The following theorem demonstrates that DTE-MCBFs are zeroing CBFs in the sense that all negative eigenvalues converge exponentially to zero under under any control law u ( x k ) ∈ K H ( x k ) .

Theorem 4. Let H be a DTE-MCBF for the system (3) with constant 0 &lt; γ ≤ 1 . For brevity, we denote H k ≜ H ( x k ) . Let the eigenvalues of H k be ordered as λ 1 ( H k ) ≤ λ 2 ( H k ) ≤ · · · ≤ λ p ( H k ) . Suppose that u k ∈ K H ( x k ) for all k ≥ 0 . Then the following holds:

<!-- formula-not-decoded -->

Proof. Define ∆ γ H k ≜ H k +1 -(1 -γ ) H k = H ( f ( x k ) + g ( x k ) u k ) -(1 -γ ) H ( x k ) . By Definition 5, the control input u k ∈ K H ( x k ) ∀ k ≥ 0 implies that ∆ γ H ⪰ 0 .

Observe that H k +1 = (1 -γ ) H k +∆ γ H k . By Weyl's Inequality (Theorem 1), it follows that

<!-- formula-not-decoded -->

However, note that λ 1 (∆ γ H k ) ≥ 0 since ∆ γ H ⪰ 0 by the definition of K H in (12). This implies that λ 1 ((1 -γ ) H k ) ≤ λ 1 ((1 -γ ) H k ) + λ 1 (∆ γ H k ) . It follows from (14) that

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

The result follows by repeated application of (16):

<!-- formula-not-decoded -->

In particular, Theorem 4 implies that if x 0 ̸∈ S , the state x k will converge exponentially to the safe set S under a control law u ( x k ) ∈ K H ( x k ) .

If H is a DTE-MCBF and a nominal feedback control law u nom ( x k ) is given, a safe control input u ∗ ( x k ) ∈ K H ( x k ) can be computed via the following optimization problem:

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

However, this optimization problem may not be convex in general due to the constraint (17b). In the next section we address this issue.

## B. Computing Safe Inputs Using Convex Projection

We begin by considering the following two classes of safe set functions H . The definition of matrix concavity is given in the Appendix (Section VI).

- Safe sets that are matrix concave in their argument
- Safe sets that are not matrix concave in their argument.

For safe sets that are matrix concave in their argument, observe that the constraint (17b) is matrix convex in the optimization variable u . This follows because the composition of a convex function with an affine function is also convex. The optimization problem (17) is therefore convex and can be solved with standard conic optimization solvers.

We turn our attention to the more difficult case of safe sets H that are not matrix concave in their arguments. Recall that H defines the safe set S via its superlevel sets. The following assumption is made on the unsafe set S :

Assumption 1. Given a safe set S defined by the sublevel sets of H , the closure of the unsafe set cl ( S ) = cl ( R n \ S ) is a subset of a finite number of closed, convex sets. More precisely, cl ( S ) ⊂ ⋃ Q i =1 S i . In addition, for each S i there exists a matrix convex function H i : R n → S such that S i = { x ∈ R n : H i ⪯ 0 } .

In the trivial case any nonconvex unsafe set S is a subset of its convex hull; i.e., cl ( S ) ⊂ co ( S ) . As this can be overly conservative, however, Assumption 1 also includes cases where the unsafe set can be decomposed into a finite number of closed, convex sets.

Since the set S is nonconvex and therefore the function H is not matrix concave, the optimization constraint (17b) is nonconvex. However, we can instead iteratively consider a convex subset of S based on the current state x k . Our proposed method is as follows: At each timestep k such that x k ̸∈ S i , observe that the sets { x k } and S i are both nonempty, disjoint, closed convex sets, with the set { x k } being trivially compact. By the separating hyperplane theorem [18, Sec. 2.5.1], there exists a hyperplane defined by a i : R n → R n , b i : R n → R such that ( a i ( x k )) ⊺ x k -b i ( x k ) &gt; 0 and ( a i ( x k )) ⊺ z &lt; b i ( x k ) for all z ∈ S i .

The form of a i , b i is determined by the vector x k -P S i x k , where P S i x k is the projection of x k onto the set S i . This projected point can be computed via the following convex optimization problem:

<!-- formula-not-decoded -->

Once this projected point has been computed, the supporting hyperplane parameters a i ( x k ) , b i ( x k ) can be explicitly defined as

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

for some ϵ &gt; 0 .

Lemma III.2. Let a i , b ϵ i be defined as in (19) for some ϵ &gt; 0 . Suppose that x k / ∈ S i . Then the following holds:

<!-- formula-not-decoded -->

Proof. We first demonstrate that the vector x k -P S i ( x k ) is in the normal cone N S i ( P S i ( x k )) . Using Theorem 2, observe that

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

∥ ∥

Since ∥ x k -P S i ( x k ) ∥ 2 &gt; 0 it follows that x k -P S i ( x k ) ∥ ∥ ∥ x k -P S i ( x k ) ∥ ∥ ∥ 2 ∈ N S i ( P S i ( x k )) Next, by Definition 2 it holds that ( x k -P S i ( x k ) ∥ ∥ ∥ x k -P S i ( x k ) ∥ ∥ ∥ 2 ) ⊺ ( z -P S i ( x k ) ) ≤ 0 &lt; ϵ ∀ z ∈ S i . Rearranging yields

<!-- formula-not-decoded -->

which by (19) is equivalent to a i ( x k ) ⊺ z &lt; b ϵ i ( x k ) for all z ∈ S i .

Lemma III.2 implies that S i is a subset of the interior of the halfspace defined by { y ∈ R n : a i ( x k ) ⊺ y &lt; b ϵ i ( x k ) } , y ∈ R m for all values of ϵ &gt; 0 . On the other hand, by definition observe that the condition a i ( x k ) ⊺ z -b ϵ i ≥ 0 is equivalent to

<!-- formula-not-decoded -->

When x k ̸∈ S i , the parameter ϵ ensures that the equations (19) are well-defined by controlling the distance between the hyperplane a i ( x k ) ⊺ y = b ϵ i ( x k ) and the boundary of the set S i . A positive ϵ adds a buffer between the boundary and the hyperplane; thus, the parameter ϵ is called the buffer distance .

Now consider the following revised safe set functions:

<!-- formula-not-decoded -->

Each h ϵ i is linear in z , which implies H ϵ is therefore matrix concave in z . In particular, the constraint H ϵ ( z, x k ) ⪰ 0 enforces the inequality min i ( { h ϵ i ( z, x k ) } Q i =1 ) ≥ 0 .

Lemma III.3. Let x k ̸∈ S i for all i = 1 , . . . , Q . Then the set { z ∈ R n : H ϵ ( z, x k ) ⪰ 0 } is disjoint from S i for all i = 1 , . . . , Q .

Proof. The result follows from Lemma III.2 and equations (24)-(25).

By Lemma III.3, the set { z ∈ R n : H ϵ ( z, x k ) ⪰ 0 } is a convex subset of the safe set S . However, observe that each h ϵ i and H ϵ is a two-argument function where the second argument determines the subset of the safe set being considered and the first argument is the point whose safety is being determined. This two-argument form motivates a new class of safe set functions and control barrier functions which are outlined in the next two definitions.

Definition 6. Let S ⊂ R n . A function H : R n × R n → S p is called a weak safe subset function for S if there exists a domain D ⊃ S such that the following holds for all x ∈ D :

<!-- formula-not-decoded -->

A function H is called a safe subset function if it is a weak safe subset function and H ( x, x ) ⪰ 0 for all x ∈ S .

Definition 7. A safe subset function H : R n × R n → S p is called a Subset-based Discrete-Time Exponential Matrix Control Barrier Function (SDTE-MCBF) for the system (3) if there exists a constant 0 &lt; γ ≤ 1 and a domain D ⊃ S such that for all x ∈ D there exists a control input u ∈ R m satisfying

<!-- formula-not-decoded -->

When the safe subset described by H is obtained through projection-based methods (as described previously in this section), we will refer to H as a Projectionbased Discrete-Time Exponential Matrix Control Barrier Function (PDTE-MCBF). A PDTE-MCBF is a special case of SDTE-CBFs since it is possible that a safe subset could be obtained by means other than projections. However, we leave further investigation of this distinction for future work.

Given a safe subset function H , consider the following set of control inputs:

<!-- formula-not-decoded -->

The following theorem demonstrates that K H ( x k ) represents the set of control inputs u that render the set S forward invariant.

Theorem 5. Let H be an SDTE-MCBF on a domain D ⊃ S for the system (3) . Then any control law u ( x k ) such that u ( x k ) ∈ K H ( x k ) for all k ≥ 0 renders the safe set S forward invariant.

Proof. Suppose x 0 ∈ S . The fact that H is a SDTEMCBF implies that it is a safe subset function by Definition 7, which implies H ( x 0 , x 0 ) ⪰ 0 by Definition 6. The fact that u ( x 0 ) ∈ K H ( x 0 ) implies that H ( f ( x 0 ) + g ( x 0 ) u ( x 0 ) ⪰ (1 -γ ) H ( x 0 , x 0 ) ⪰ 0 . It follows that x 1 ∈ S . Proceeding inductively, assume that x k ∈ S . By similar arguments it follows that x k +1 ∈ S and H ( f ( x k ) + g ( x k ) u ( x k ) , x k ) ⪰ (1 -γ ) H ( x k , x k ) ⪰ 0 , which concludes the proof.

Given these definitions, we now formally prove that the function H ϵ can be classified as a safe subset function.

Lemma III.4. Let S be nonempty, and suppose S satisfies Assumption 1. Let H ϵ be defined as in (25). Choose D = S and define S ϵ = { z ∈ S : dist ( x, S ) ≥ ϵ } ⊂ D , where the distance is defined in terms of the Euclidean norm. Then H ϵ is a safe subset function for S ϵ .

Proof. By the properties of convex sets and Lemma III.2, a i ( x ) ⊺ z -b ϵ i ( x ) ≥ 0 = ⇒ ( x -P S i ( x ) ∥ ∥ ∥ x -P S i ( x ) ∥ ∥ ∥ ) ⊺ ( z -P S i ( x ) ) ≥ ϵ implies that dist ( z, S i ) ≥ ϵ for all i = 1 , . . . , Q . By equation (25), it follows that all points in the set { z ∈ R n : H ϵ ( z, x ) ⪰ 0 } satisfy dist ( z, S ) ≥ ϵ , and therefore { z ∈ R n : H ϵ ( z, x ) ⪰ 0 } ⊂ S ϵ . The function H ϵ is therefore a weak safe set function.

Next, choose any x ∈ S ϵ . It holds that ∥ ∥ x -P S i ( x ) ∥ ∥ 2 ≥ ϵ , which implies that a i ( x ) ⊺ x -b ϵ i ( x ) ≥ 0 for all i = 1 , . . . , Q . It follows that H ϵ ( x, x ) ⪰ 0 for all x ∈ S ϵ .

Since the definition of SDTE-MCBF relies upon the specific dynamics under consideration, proofs that H ϵ form a SDTE-MCBF will require case-by-case analysis. Note that any H ϵ as defined in (25) that qualifies as a SDTE-MCBF is also a PDTE-MCBF since the subset of the safe set is obtained via projections. Under the assumption that H ϵ is an SDTE-MCBF (or PDTEMCBF) and given a nominal control input u nom ( x k ) and the projected points { P S i ( x k ) } Q i =1 , it is possible to compute a safety-preserving control input u ∗ ( x k ) ∈ K ϵ H ( x k ) using the following convex QP:

<!-- formula-not-decoded -->

## Algorithm 1: Safe Input Computation for PDTE-MCBF

<!-- formula-not-decoded -->

Algorithm 1 summarizes the process of computing safe control inputs u ∗ ( x k ) for the form of PDTEMCBFs defined in this paper. For simplicity, algorithm 1 shows each projection point P S i ( x k ) being computed by a separate optimization problem instance. However, we note that all projection points ⃗ P ≜ [ P S 1 · · · P S Q ] ⊺ can be computed simultaneously in a single optimization instance as follows:

<!-- formula-not-decoded -->

We point out that our proposed method only requires solving two sequential convex optimization problems per time step k , the second of which is a QP. In special cases where S i takes a specific form such as a circle or ellipse, it is possible to obtain the projection point directly in closed-form. Compared to prior nonconvex formulations for discrete-time CBFs, our convex optimization method has polynomial-time computational complexity and guarantees convergence to globally optimal solutions.

## C. Zeroing Properties of the Projection Method

The original notion of discrete-time exponential control barrier functions renders safe sets exponentially stable in the state space [8]. In other words, if the initial state x 0 is in the unsafe set S , a safe control input derived from a discrete-time exponential CBF causes x k to converge exponentially to the safe set S . The convex projection method under Assumption 1 in general operates only when the state x k does not coincide with any of the projections P S i ( x k ) onto the unsafe sets S i , i = 1 , . . . , Q . If x k ∈ S i , then P S i ( x k ) = x k and the prior formulas for a i , b i result in ill-defined constraints. Deriving methods to ensure x k ∈ S converges exponentially to S is more difficult in general for the projection method proposed previously; however this section presents methods to render S asymptotically stable when x k ∈ S .

̸

If x k ∈ ∂S i , we may use the normal cone N S i ( x k ) to compute a safe control input. Choose any x N ( x k ) ∈ N S i ( x k ) such that x N ( x k ) = x k and x N ( x k ) -x k ∈ N S i ( x k ) . Define the functions ̂ a ∂ i : R n → R n , ̂ b ∂,ϵ i : R n → R as

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

We can then define the safe set function

<!-- formula-not-decoded -->

Lemma III.5. Let x k ∈ ∂S i for all i = 1 , . . . , Q . Let ϵ &gt; 0 . Then the set { z ∈ R n : h ∂,ϵ i ( z, x k ) ≥ 0 } is disjoint from S i for all i = 1 , . . . , Q .

Proof. By definition, x N ( x k ) -x k ∈ N S i ( x k ) . The result follows using similar arguments as Lemma III.2 and Lemma III.3

The safe set function ̂ h ∂,ϵ i may be used in place of h ϵ i in Algorithm 1 when x k ∈ ∂S i .

The more difficult case is when the state is in the interior of the unsafe set; i.e., x k ∈ int ( S i ) . In this case the normal cone is trivially the zero vector: N S i ( z ) = { 0 } ∀ z ∈ S i . We therefore use the notion of depth of a convex set. The depth function depth : R n × 2 R n → R is defined as

<!-- formula-not-decoded -->

where C is a subset of R n . For convex sets such as S i under Assumption 1, the depth can be computed as [18, Sec. 8.5.1]

<!-- formula-not-decoded -->

This optimization problem is convex, but the functions g j are difficult to evaluate in general. However, the optimization problem in (35) is tractable for specific classes of convex functions. When S i is a polytope in halfspace form a ′ ⊺ i,j x k ≤ b ′ i,j , depth ( x k , S i ) can be computed via the following linear program [18, Sec. 8.5.1]:

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

When S i takes the form of an intersection of ellipsoids defined by quadratic inequalities S i = { x : x ⊺ M i,j x + 2 v ⊺ i,j x + d i,j ≤ 0 , j = 1 , . . . , J ′ , M i,j ∈ R n × n , v i,j ∈ R n , d i,j ∈ R , the depth can be computed via the following convex SDP [18, Sec. 8.5.1]:

depth ( x k , S i ) =

<!-- formula-not-decoded -->

Due to the nature of the objective function (35), the value of depth ( x k , S i ) is equal to the value of the optimal point R ∗ ( x k ) . Using the implicit function theorem, it is possible to obtain a descent direction for the depth by computing ∂ ∂x depth ( x k , S i ) = ∂R ∗ ( x k ) ∂x using standard methods to backpropagate through convex optimization programs [19]. The following halfspaces can then be defined:

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

We can then define the function

<!-- formula-not-decoded -->

which may be used in place of h ϵ i in Algorithm 1 when x k ∈ int ( S i ) .

Lemma III.6. Let S i be defined as in Assumption 1. Let h R i be defined as in (39). Let x k ∈ int ( S i ) and let z ∈ R n be any vector z satisfying h R i ( z, x k ) ≥ (1 -γ ) h R i ( x k , x k ) for some 0 &lt; γ ≤ 1 . Then depth ( z, S i ) &lt; depth ( x k , S i ) .

Proof. By definition, R ∗ i ( x k ) = depth ( x k , S i ) . The vector -∂R ∗ i ( x k ) /∂x ∥ ∂R ∗ i ( x k ) /∂x ∥ can be considered an element of the normal cone to the convex set C i ( x k ) = { y ∈ R n : R ∗ i ( x k ) ≤ R ∗ i ( y ) } , where x k ∈ ∂C i ( x k ) . Observe that h R i ( x k , x k ) = R ∗ i ( x k ) . The equation h R i ( z, x k ) ≥ h R i ( x k , x k can therefore be rewritten as

<!-- formula-not-decoded -->

Since R ∗ i ( x k ) &gt; 0 for x k ∈ S i and 0 &lt; γ ≤ 1 , we therefore have R ∗ i ( z ) &lt; R ∗ i ( x k ) , or equivalently depth ( z, S i ) &lt; depth ( x k , S i ) .

Finally, observe that h R i ( f ( x ) + g ( x ) u, x k ) is affine and therefore concave in u , which empowers rapid computation of feasible control inputs u using convex optimization techniques.

## D. Indefinite Matrix Safe Sets

The recent work [14] introduced the notion of indefinite safe sets defined as

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

Here, recall that by convention the eigenvalues of H are ordered λ 1 ( H ( x )) ≤ λ 2 ( H ( x )) ≤ · · · ≤ λ p ( H ( x )) . Indefinite safe sets have application to enforcing disjunctive boolean constraints on multiple CBFs [14]. We generalize this notion of indefinite safe sets as follows:

<!-- formula-not-decoded -->

In words, S ( j ) represents the states where eigenvalues j through p are non-negative. If we let r = p -j , then this represents enforcing r out of p constraints to be active at any time. We next show that the set S ( j ) may be rendered forward invariant by enforcing the following constraint at every time step k ≥ 0 for some 0 &lt; γ ≤ 1 :

<!-- formula-not-decoded -->

Given the dynamics (3), define the set-valued mapping K ( j ) H : R n → 2 R m as

<!-- formula-not-decoded -->

Theorem 6. Let S ( j ) be defined as in (43) and let K ( j ) H be defined as in (45) . Let x 0 ∈ S ( j ) . Then any control input u ( x k ) ∈ K ( j ) H ( x k ) ∀ k ≥ 0 renders the set S ( j ) forward invariant. Furthermore, such a u ( x k ) renders the set S ( j ) exponentially stable in R n .

Proof. For brevity denote H k = H ( x k ) . Define ∆ ( j ) H k ≜ H k +1 -( H k -γλ j ( H k ) I p × p ) . Using Weyl's inequality (Theorem 1) and setting i = j , we have

<!-- formula-not-decoded -->

However, u ( x k ) ∈ K ( j ) H ( x k ) implies that λ 1 (∆ ( j ) H k ) ≥ 0 . It follows that

<!-- formula-not-decoded -->

By induction, we have

<!-- formula-not-decoded -->

It follows that S ( j ) is both forward invariant and exponentially stable in R n .

The set of control inputs within K ( j ) H ( x k ) ensure that the largest eigenvalues λ j through λ p remain positive, but the smallest eigenvalues λ 1 through λ j -1 are free to remain negative. This behavior relates to recent work on combinatorial ' p -chooser ' CBFs [15], however our contributions here apply to discrete-time CBFs. Given a nominal control input u nom ( x k ) , control inputs within K ( j ) H ( x k ) may be computed using the following optimization formulation:

<!-- formula-not-decoded -->

The results in preceding sections may be applied to ensure that this optimization formulation is convex.

## IV. NUMERICAL SIMULATIONS

In this section, the PDTE-MCBF technique developed in the previous section and shown in Algorithm 1 is implemented in numerical examples. This section also provides a performance comparison between the proposed PDTE-MCBF technique and nonconvex CBF formulations. Note that in this work, the numerical examples are constrained to a plane in which only horizontal and vertical motion is permitted and thus only two-dimensional obstacles are considered. Consequently, the subindices h and v used in the variables to denote a connection to horizontal and vertical coordinates, respectively. For instance, p h and p v are used in these examples to denotes positions in the horizontal and vertical directions, respectively.

First, an overview of the obstacles considered in the numerical examples is provided, in which the unsafe sets, matrix convex functions, the projected point calculations, and the safe sets associated with each obstacle are discussed; in particular, analogous parameters to the previously defined buffer distance ϵ are defined for the safe sets of each obstacle. Then, two systems are considered: a system in a plane composed of two double integrators and the outer-loop controller of a bicopter lateral flight system. The nominal controllers in the examples are given by reference tracking LQR controllers. The details of this implementation are omitted for brevity and since the main focus of the paper is the performance of the CBF. The implementation of the PDTE-MCBF technique requires the solution of a constrained linear least-squares optimization problem, as shown in (30). In all examples, this problem is solved by using the lsqlin solver from Matlab with the active-set algorithm. The solver for nonconvex CBF formulations is discussed in each numerical example.

Furthermore, in this work, the safe sets for obstacle avoidance depend only on the position states. Hence, there exists C pos ∈ R 2 × n , such that C pos x ∈ R 2 yields the position state vector related to state x. Thus, (19) is rewritten as

<!-- formula-not-decoded -->

The matrix convex functions presented in the obstacle subsection are also defined in terms of the C pos operator.

All computational results in this paper were obtained using a laptop PC running Windows 10 Pro, version 22H2, OS build 19045.6332, with an Intel Core i710750H processor running at 2.60 GHz and a 32GB, 3200 MHz RAM, with MATLAB version R2024b Update 5.

## A. Obstacles

The four obstacles considered in this work are a circle, an ellipse, a convex polytope, and a spectrahedron, which are shown in Figure 2. Their properties and the projected point calculation procedure and the CBF associated with each of these obstacles are presented next.

1) Circle: A circle C is defined by a center position p C ∈ R 2 and a radius r C . For a circle C obstacle, the unsafe set is given by

<!-- formula-not-decoded -->

and thus, the corresponding matrix convex function describing the unsafe set is given by

<!-- formula-not-decoded -->

Note that the projection of a state vector x k onto the set S C , given by (18) can be expressed in closed-form as

<!-- formula-not-decoded -->

which can be used to calculate the projected point without solving an optimization problem. Finally, it follows from the unsafe set (49) that the CBF associated with the circle obstacle safe set S C with buffer distance ϵ C is given by

<!-- formula-not-decoded -->

which can be used to implement the safe control input constraints shown in (7b). Note that ϵ C increases the radius of the unsafe set considered by the CBF.

2) Ellipse: An ellipse El is defined by a center position p El ∈ R 2 , the semi-major axis unit vector v El ∈ R 2 , such that ∥ v El ∥ 2 = 1 , and the semimajor and semi-minor axes lengths ℓ El , 1 ≥ ℓ El , 2 &gt; 0 , respectively. Let Q El △ = [ v El v El , ⊥ ] ∈ R 2 × 2 , where v El , ⊥ △ = [ 0 -1 1 0 ] v El , and let

<!-- formula-not-decoded -->

Then, for an ellipse El obstacle, the unsafe set is given by

<!-- formula-not-decoded -->

and thus, the corresponding matrix convex function is given by

<!-- formula-not-decoded -->

Note that the projection of a state vector x k onto the set S El , given by (18) can be formulated as a secondorder cone optimization problem; in this work, this optimization problem is solved by using the coneprog solver from Matlab. Finally, it follows from the unsafe set (53) that the CBF associated with the ellipse obstacle safe set S El with buffer distance ϵ El is given by

<!-- formula-not-decoded -->

where

<!-- formula-not-decoded -->

and which can be used to implement safe control input constraints shown in (7b). Note that ϵ El increases the lengths of the semi-major and semi-minor aces of the ellipse corresponding to the unsafe set considered by the CBF.

3) Convex Polytope: A convex polytope P is defined by a matrix composed by n P vertices, given by v P ∈ R 2 × n P . Then, for a polytope P obstacle, the unsafe set is given by

<!-- formula-not-decoded -->

where -A P ,i ∈ R 1 × 2 , -b P ,i ∈ R are associated with the halfspace that is determined by the i -th edge of P and that does not contain the mean of all n P vertices. Hence, the corresponding matrix convex function is given by

<!-- formula-not-decoded -->

Note that the projection of a state vector x k onto the set S P , given by (18) can be written as

<!-- formula-not-decoded -->

and thus can be formulated as a constrained linear leastsquares problem; in this work, this optimization problem is solved by using the lsqlin solver from Matlab with the active-set algorithm option. This problem is warm-started by providing the closest vertex to C pos x k as an initial solution. Next, it follows from the unsafe set (56) that the safe set corresponding to the polytope obstacle is given by

<!-- formula-not-decoded -->

In order to derive a CBF for this union of sets, a discretetime version of the CBF constraint proposed in (15) from [15] is formulated. Using a combinatorial CBF was required for the implementation of the CBF associated with the polytope, and we will explore this connection in more detail in future work. Hence, the safe input constraints associated with the polytope safe set S P with buffer distance ϵ P that replace (7b) are given by

<!-- formula-not-decoded -->

where γ ∈ [0 , 1] ,

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

where, for all i ∈ { 1 , . . . , n P } , η i ∈ {-1 , 1 } is chosen so that the distance between the hyperplane given by h P ,i and the center of P is increased by ϵ P relative to the case where η i = 0 .

4) Spectrahedron: A spectrahedron Sp in R 2 is defined by a center position p Sp ∈ R 2 , matrix size n Sp , symmetric matrices A 0 , Sp , A 1 , Sp , A 2 , Sp ∈ R n Sp × n Sp , and rotation angle θ Sp in radians. Then, for a polyhedron Sp obstacle, the unsafe set is given by

<!-- formula-not-decoded -->

where R θ Sp ∈ R 2 × 2 is the rotation matrix associated with θ Sp . Hence, the corresponding matrix convex func- tion is given by

<!-- formula-not-decoded -->

Note that the projection of a state vector x k onto the set S Sp requires the solution of the convex, semidefinite optimization problem given by (18); in this work, this optimization problem is solved using the MOSEK solver interfaced with the YALMIP toolbox. Next, it follows from the unsafe set (63) that the safe set corresponding to the spectrahedron obstacle is given by

<!-- formula-not-decoded -->

since positive semidefiniteness does not hold if at least one of the eigenvalues of the associated real symmetric matrix is negative. In order to derive a CBF for this indefinite inequality, a discrete-time version of the CBF constraint proposed in (19) from [14] is formulated. Using an indefinite matrix CBF was required for the implementation of the CBF associated with the spectrahedron, and we will explore this connection in more detail in future work. Hence, the safe input constraint associated with the spectrahedron safe set S Sp with buffer ratio ϵ Sp ∈ [0 , 1) that replaces (7b) is given by

<!-- formula-not-decoded -->

where γ ∈ [0 , 1] , c ⊥ ∈ [0 , 1] , and

<!-- formula-not-decoded -->

Note that, unlike the other obstacles, ϵ Sp represents a ratio which increases the size of the unsafe set considered by the CBF the closer its value is to 1, since distance cannot be intuitively defined relative to any of the spectrahedron parameters.

## B. Discretized double integrators

Robotic agents are frequently represented using double-integrator dynamics, which capture the relationship between acceleration, velocity, and position. In this example, we consider the design of a safety-critical controller for an agent whose dynamics are governed by a double-integrator model. In particular, consider two discretized double integrators

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

Fig. 2: Typical obstacle geometries. The figure shows a) circle (IVA.1), b) ellipse (IV-A.2), c) convex polytope (IV-A.3), and d) spectrahedron (IV-A.4) shaped obstacles.

<!-- image -->

where p h ,k , p v ,k ∈ R denote the translations in the horizontal and vertical directions, respectively, v h ,k , v v ,k ∈ R denote the velocities in the horizontal and vertical directions, respectively, u h ,l , u v ,k ∈ R are horizontal and vertical acceleration commands, respectively, and the discretized state transition matrices are

<!-- formula-not-decoded -->

Note that (67), (68) can be written as

<!-- formula-not-decoded -->

where x k △ = [ p h ,k v h ,k p v ,k v v ,k ] T , u k △ = [ u h ,k u v ,k ] T , A △ = diag( A d , A d ) , and B △ = diag( B d , B d ) . In this example, C pos = [ 1 0 0 0 0 0 1 0 ] , and we set T s = 0 . 01 s. Let r k ∈ R 4 be a reference state for x k . Hence, the objective of the nominal controller is to minimize ∑ ∞ k =0 ∥ r k -x k ∥ .

Consider a reference tracking nominal controller

<!-- formula-not-decoded -->

where u nom ,k ∈ R is the requested control input and f lqr encodes an LQR controller. As mentioned at the beginning of this section, the details of the LQR controller implementation are omitted for brevity and since the main focus of the paper is the performance of the CBF.

The obstacles considered in this example are the following:

- A circle obstacle C with p C = [ 18 16 ] T m, and r C = 1 . 5 m.
- An ellipse obstacle El with p El = [ 2 . 5 5 ] T m, v El = [ 1 / √ 2 -1 / √ 2 ] T , and ℓ El , 1 = √ 10 m, ℓ El , 2 = √ 2 ,
- A convex polytope obstacle P given by a regular pentagon ( n P = 5 ) with center at [ 14 11 ] T and a distance of 2 m from the center to each of its vertices.
- A spectrahedron obstacle Sp with p Sp = [ 7 . 5 7 . 5 ] T m, n Sp = 3 , θ Sp = 0 , and

<!-- formula-not-decoded -->

Two different CBF formulations are compared in the following example, the PDTE-MCBF formulation and a nonconvex CBF formulation:

- For the PDTE-MCBF formulation, the control input u k is obtained by solving the constrained linear least-squares optimization problem

<!-- formula-not-decoded -->

where H ϵ is given by (24), (25) with Q = 4 , each of the indices i ∈ { 1 , 2 , 3 , 4 } corresponding to each of the obstacles, a i , b ϵ i given by (48), and the projections P S i are calulated using (18) with the corresponding H i for each obstacle given by (50), (54), (57), (64). Algorithm 1 is used to formulate and solve (71). This constrained linear least-squares optimization problem is solved at each iteration using the lsqlin Matlab solver with the active-set algorithm option. This problem is warm-started by providing the nominal input u nom ,k as an initial solution. Furthermore, the optimization problem formulations to calculate the projections corresponding to each obstacle are discussed in Subsection IV-A. For this example, γ = 0 . 2 , and ε = 0 . 4 .

- For the nonconvex CBF formulation, the control input u k is obtained by solving the nonconvex, semidefinite optimization problem

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

with h C , h El given by (52), (55), respectively, and f ( x k ) = Ax k , g ( x k ) = B in (60), (66). This nonconvex, semidefinite optimization problem is solved at each iteration using the bmibnb solver from the YALMIP toolbox, interfaced with MOSEK . This problem is warm-started by providing the nominal input u nom ,k as an initial solution. For this example, γ = 0 . 2 , ϵ C = ϵ El = ϵ P = 0 . 4 , ϵ Sp = 0 . 25 , and c ⊥ = 0 . 05 .

For all simulations, we set x 0 = 0 , and r k ≡ [ 18 0 20 0 ] T . The simulations are run for all k ∈ { 0 , k end } , with k end = 1200 . The results of the simulations with the PDTE-MCBF and nonconvex CBF formulations are shown in Figures 3 and 4, respectively. The optimization problems run at each iteration returned feasible solutions in both simulations. Figures 3 and 4 show the trajectory of the double integrators, the unsafe sets given by the obstacles, and the buffer sets, which correspond to the unsafe sets considered by the corresponding CBF formulations and facilitated by the buffer distances ϵ, ϵ C , ϵ El , ϵ P and the buffer ratio ϵ Sp . The following can be concluded from both figures:

- The boundaries of the buffer sets resulting from the PDTE-MCBF formulation are more equidistant from the obstacle boundaries than the boundaries of the buffer sets resulting from the nonconvex CBF formulation; this is better observed when comparing the buffer sets corresponding to the pentagon and spectahedron obstacles in both figures.
- The buffer sets resulting from the PDTE-MCBF formulation are similar to the Minkowski sum of the unsafe sets and a circle of radius ϵ m.
- The tracking and obstacle avoidance performances of both CBF formulations are very similar.

Finally, Table I shows the average runtime per iteration for all CBF formulations for each of the simulations. In the case of PDTE-MCBF, the runtime without calculation of projected points refers to the runtime for solving (71) without calculating the projections P S i , and the runtime with calculation of projected points includes the runtime for solving (71) considering the entirety of Algorithm 1. The results in Table I show that the total runtime of the PDTE-MCBF formulation is more than an order of magnitude faster than the nonconvex CBF formulation.

## C. Bicopter lateral flight

Consider the bicopter in the vertical plane shown in Figure 5, which consists of a rigid frame with two rotors that generate thrust along their respective axes. The bicopter has mass m , center of mass c , moment of inertia J about c , and the distance between the rotors is ℓ mc . Let T 1 , T 2 denote the thrusts produced by the left and right rotors, respectively, as shown in Figure 5. Define the total thrust T △ = T 1 + T 2 and the total moment τ △ = ( T 1 -T 2 ) /ℓ mc . Then, the dynamics of the bicopter

Fig. 3: Discretized double integrators with PDTE-MCBF formulation. The figure shows the trajectory of an agent modeled by double integrators for all k ∈ [0 , k end ] with k end = 1200 , the unsafe sets given by the obstacles, and the buffer sets, which are obtained by setting the buffer distance ϵ = 0 . 4 .

<!-- image -->

Fig. 4: Discretized double integrators with nonconvex CBF formulation. This figure shows the trajectory of an agent modeled by double integrators for all k ∈ [0 , k end ] with k end = 1200 , the unsafe sets given by the obstacles, and the buffer sets, which are obtained by setting the buffer distances ϵ C = ϵ El = ϵ P = 0 . 4 and the buffer ratio ϵ Sp = 0 . 25 .

<!-- image -->

in the vertical plane are then given by

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

where p h , p v ∈ R are the horizontal and vertical positions of c, respectively, v h , v v ∈ R are the horizontal

TABLE I: Average runtime per iteration for all CBF formulations. The runtime without calculation of projected points refers to the runtime for solving (71) without calculating the projections P S i . The runtime with calculation of projected points includes the runtime for solving (71) considering the the entirety of Algorithm 1.

| CBF formulation                                     | Average runtime per iteration (s)   |
|-----------------------------------------------------|-------------------------------------|
| PDTE-MCBF (without calculation of projected points) | 1.036 × 10 - 3                      |
| PDTE-MCBF (with calculation of projected points)    | 6.002 × 10 - 2                      |
| Nonconvex CBF                                       | 2.543                               |

and vertical velocities of c, respectively, θ ∈ R is the bicopter tilt, ω ∈ R is the bicopter angular velocity, and g is the acceleration due to gravity.

Fig. 5: A bicopter system whose motion is constrained in a vertical plane.

<!-- image -->

A discrete-time controller is implemented to control the continuous-time dynamics shown in (74)-(76). Hence, the states p h , v h , p h , v h , θ, ω are sampled to produce the sampled states

<!-- formula-not-decoded -->

where k ≥ 0 is the discrete-time step, and T s &gt; 0 is the sampling time. The controller generates the total thrust T k ≥ 0 and the total torque τ k ∈ R . The continuous-time signals T and τ applied to the bicopter are generated by applying a zero-order hold operation to T k and τ k , that is, for all k ≥ 0 ,

<!-- formula-not-decoded -->

The nominal controller is designed so that p h ,k and p v ,k follow reference signals r h ,k and r v ,k , respectively, such that the objective of the nominal controller is to minimize ∑ ∞ k =0 ∥ ∥ ∥ [ r h ,k r v ,k ] T -[ p h ,k p v ,k ] T ∥ ∥ ∥ . For this purpose, the inner-loop, outer-loop control architecture shown in Figure 6 is adopted. An advantage of this architecture is that it allows the dynamics shown in (74)(76) to be decoupled into linear systems, such that the resulting decoupled, discretized dynamics are given by

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

where x h ,k △ = [ p h ,k v h ,k ] T , x v ,k △ = [ p v ,k v v ,k ] T , x att ,k △ = [ θ k ω k ] T , u h ,k , u v ,k ∈ R are horizontal and vertical acceleration commands, respectively, and

<!-- formula-not-decoded -->

The dynamics shown in (78)-(80) only hold near hover conditions ( θ ≈ 0 deg) and are used to design the outerloop and inner-loop controllers

Let the outer-loop controller G c , ol be given by two LQR controllers for the horizontal and vertical states separately, such that

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

where f lqr , i , h , f lqr , i , v implement LQR controllers with integrator states and different sets of gains; Algorithm 1 in [20] shows an implementation the LQR controllers mentioned above. As mentioned at the beginning of this section, more details of the LQR controllers are omitted for brevity and since the main focus of the paper is the performance of the CBF.

Next, in this example, the function f cbf is a safety filter that implements either the PDTE-MCBF formulation or the nonconvex CBF formulation. The inputs of f cbf are u nom ,k △ = [ u nom , h ,k u nom , v ,k ] T and x k △ = [ x T h ,k x T v ,k ] T , and the output of f cbf is u k △ = [ u h ,k u v ,k ] T . In this example, C pos = [ 1 0 0 0 0 0 1 0 ] . The implementation details for both CBF formulations are given later.

The outer and inner loops are linked by a nonlinear mapping function f map that can be used to obtain the thrust T k and a reference tilt value θ r ,k from u k , such that

<!-- formula-not-decoded -->

Then, the inner-loop controller G c , il is given by a LQR controller for the attitude states, such that

<!-- formula-not-decoded -->

where f lqr , i , att implements the LQR controller whose implementation is shown in Algorithm 1 in [20]. As mentioned at the beginning of this section, more details of the LQR controllers are omitted for brevity and since the main focus of the paper is the performance of the CBF.

Fig. 6: Inner-loop, outer-loop control architecture used for bicopter tracking control.

<!-- image -->

Next, safe set details are discussed. In this example, the only obstacle considered is a circle obstacle with p C = [ 2 -0 . 75 ] T m, and r C = 1 m, which entails constraints on the position states, addressed by the previously introduced CBF formulations. Aside from these constraints, velocity constraints and reference tilt constraints are considered to increase the likelihood that the safe inputs obtained by the CBFs do not cause a large deviation from hover conditions, which are assumed in the design of both the outer-loop and the inner-loop controllers. Hence, for all steps k ≥ 0 , the following velocity and reference tilt constraints are considered

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

where v h , max , v v , max , θ r , max &gt; 0 are the maximum absolute values of the horizontal and vertical velocities, and the reference tilt, respectively. The CBF associated with the constraints (85), (86) is given by

<!-- formula-not-decoded -->

and thus the safe input constraints associated with the velocity states are given by

<!-- formula-not-decoded -->

where γ ∈ [0 , 1] , A △ = diag( A pos , A pos ) , and B △ = diag( B pos , B pos ) , which results in an affine, convex constraint. Next, it follows from (83) that safe input constraints associated with the reference tilt constraint (87) is given by

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

Two different CBF formulations are compared in the following example, the PDTE-MCBF formulation and a nonconvex CBF formulation:

- For the PDTE-MCBF formulation, the control input u k is obtained by solving the constrained linear least-squares optimization problem

<!-- formula-not-decoded -->

where H ϵ is given by (24), (25) with Q = 1 , and index i = 1 corresponding to the circle obstacle, a i , b ϵ i given by (48), and the projection P S i are calulated using (18) with the corresponding H i for the circle obstacle given by (50); in this case, the projection has a closed-loop solution given by (51). Algorithm 1 is used to formulate and solve (91). This constrained linear least-squares optimization problem is solved at each iteration using the lsqlin Matlab solver with the active-set algorithm option. This problem is warm-started by providing the nominal input u nom ,k as an initial solution. For this example, γ = 0 . 1 , and ε = 0 . 2 .

- For the nonconvex CBF formulation, the control input u k is obtained by solving the nonconvex, semidefinite optimization problem

<!-- formula-not-decoded -->

with h C given by (52). This nonconvex, nonlinear optimization problem is solved at each iteration using two different solvers in separate simulations. The first considered solver is the fmincon Matlab solver with the sqp algorithm option and the maximum number of iterations set to 10 5 . The second considered solver is the bmibnb solver from the YALMIP toolbox, interfaced with MOSEK . In both instances, this problem is warm-started by providing the nominal input u nom ,k as an initial solution. For this example, γ = 0 . 1 , and ϵ C = 0 . 2 .

Remark 1. The lsqlin and fmincon solvers can converge to unfeasible results that do not meet the optimization constraints and output these values. In contrast, the YALMIP -based solver does not output a numerical value if it determines that the problem is unfeasible. In this case, the YALMIP -based solver is used a second time to solve (92) with slack variables. If the YALMIP -based determines that the problem with slack variables is also unfeasible, the nominal control input is given as the output of the nonconvex, nonlinear optimization problem.

For all simulations, x ( t ) = 0 , T ( t ) = mg,τ ( t ) = 0 for all t ≤ 0 , u h ,k = u v ,k = θ r ,k = 0 for all k ≤ 0 , r h ,k ≡ 18 m, r v ,k ≡ 20 m, and T s = 0 . 005 s. The simulations are run for all t ∈ [0 , t end ] s, with t end = 10 s. The Simulink 2 environment is used for numerical simulation with the ode45 solver to solve the bicopter continuous-time dynamics. The discrete-time dynamics corresponding to the controller and either of the CBF formulations are evaluated every T s seconds.

The results of the simulations with the PDTE-MCBF and nonconvex CBF formulations are shown in Figure 7. Furthermore, the feasibility of the solutions that each solver converged to at each iteration step for the PDTEMCBF and nonconvex CBF formulations is shown in Figure 8; for the YALMIP -based solver, the problem solution is considered unfeasible if the first run without slack variables is considered unfeasible, as discussed in Remark 1. Finally, Table II shows the average runtime per iteration for all CBF formulations for each of the solvers used in the simulations; for the YALMIP -based solver, the runtime per iteration accounts for the runtime of the optimization problem with slack variables in the iterations where the first run without slack variables is considered unfeasible, as discussed in Remark 1.

In all cases, the optimization problem becomes unfeasible as the bicopter enters the buffer set. The safety filter is unable to prevent the bicopter from entering the buffer set since it only modifies the outer-loop controller outputs, which results in the inner-loop controller and the tilt angle dynamics becoming unmodeled input dynamics, which, in turn, can lead to safety violations, as discussed in [21]. However, while the nonconvex CBF formulation with the fmincon solver is unable to exit the buffer set and enters the unsafe set, the PDTEMCBF formulation and the nonconvex CBF formulation with the YALMIP -based solver are able to recover from entering the buffer set and go back to the safe set before approaching the goal. Furthermore, as shown in Table II, the total runtime of the PDTE-MCBF formulation is faster than the nonconvex CBF formulation with the fmincon solver and is more than an order of magnitude faster than the nonconvex CBF formulation with the YALMIP -based solver. A video illustrating these simulation results in the accompanying animation at https://youtu.be/eYDTqa lE4.

2 Special instructions for interfacing YALMIP -based solvers with Simulink are given in https://yalmip.github.io/example/simulink/

Fig. 7: PDTE-MCBF and nonconvex CBF closed-loop performance comparison in bicopter lateral flight system. This figure shows the trajectory of the bicopters for all t ∈ [0 , t end ] s, with t end = 10 s, the unsafe set given by the circle, and the buffer sets, which correspond to the unsafe sets considered by the CBF formulations and facilitated by the buffer distances ϵ = ϵ C = 0 . 2 . The plots show the results for a) the PDTE-MCBF formulation solved with lsqlin , b) the nonconvex CBF formulation solved with fmincon , and c) the nonconvex CBF formulation solved with the YALMIP -based solver.

<!-- image -->

Fig. 8: PDTE-MCBF and nonconvex CBF closed-loop unfeasibility comparison in bicopter lateral flight system. The iterations for which the implemented solvers converged to unfeasible solutions is shown in these plots. The plots show the results for a) the PDTE-MCBF formulation solved with lsqlin , b) the nonconvex CBF formulation solved with fmincon , and c) the nonconvex CBF formulation solved with the YALMIP -based solver. For the YALMIP -based solver, the problem solution is considered unfeasible if the first run without slack variables is considered unfeasible, as discussed in Remark 1.

<!-- image -->

TABLE II: Average runtime per iteration for all CBF formulations with their respective solvers.

| CBF formulation            | Average runtime per iteration (s)   |
|----------------------------|-------------------------------------|
| PDTE-MCBF with lsqlin      | 5.251 × 10 - 6                      |
| Nonconvex CBF with fmincon | 3.113 × 10 - 5                      |
| Nonconvex CBF with YALMIP  | 9.414 × 10 - 1                      |

## V. CONCLUSION

This paper introduced the notion of exponential discrete-time matrix control barrier functions, presented a novel method to compute safe control inputs using solely convex optimization called Projectionbased Discrete-Time Exponential Matrix Control Barrier Function (PDTE-MCBF), and demonstrated methods to handle disjunctive boolean constraints using discretetime matrix control barrier functions. Numerical simulations showed the following advantages of the proposed method relative to nonconvex optimization methods:

- The tracking and obstacle avoidance performances of both the PDTE-MCBF and the nonconvex CBF formulations are very similar.
- The boundaries of the buffer sets resulting from the PDTE-MCBF formulation are more equidistant from the obstacle boundaries than The boundaries of the buffer sets resulting from the nonconvex CBF formulation.
- The total runtime of the PDTE-MCBF formulation is more than an order of magnitude faster than the nonconvex CBF formulation.

Future work will investigate extensions of our results to multi-agent systems and systems with noise and uncertainty.

## VI. APPENDIX: MATRIX CONVEXITY

The following is an abbreviated overview of matrix convexity as defined in [18, Sec. 3.6.2]. More precisely, this definition of matrix convexity is simply S p -convexity for the proper cone S p .

Let H : R n → S p be a function with output in the space of symmetric real-valued p × p matrices.

Definition 8 (Matrix Convexity) . A mapping H : R n → S p is matrix convex if for all x, y ∈ R n and for all θ ∈ [0 , 1] , the following holds:

<!-- formula-not-decoded -->

Equivalently, H is matrix convex if and only if x ↦→ y ⊺ H ( x ) y is convex in x for all y ∈ R p .

Definition 9 (Matrix Concavity) . A mapping H : R n → S p is matrix concave if for all x, y ∈ R n and for all θ ∈ [0 , 1] , the following holds:

<!-- formula-not-decoded -->

Equivalently, H is matrix concave if and only if x ↦→ y ⊺ H ( x ) y is concave in x for all y ∈ R p .

Lemma VI.1. Let A ∈ S p + . Then for all a, b ∈ R ,

<!-- formula-not-decoded -->

Proof. Let U Λ U T be the eigendecomposition of A . We have

<!-- formula-not-decoded -->

Since A ∈ S p + , we have λ i ( A ) ≥ 0 . In addition, b -a ≥ 0 by assumption. It follows that ( b -a ) A ⪰ 0 , which holds if and only if aA ⪯ bA .

Lemma VI.2. Let { f i : R n → R } q i =1 be convex functions, let { A i ∈ S p + } q i =1 be positive semidefinite matrices, and let B ∈ S p be a symmetric matrix. Then the following function is matrix convex:

<!-- formula-not-decoded -->

Proof. Let θ ∈ [0 , 1] and x, y ∈ R n . By Lemma VI.1 and the convexity of each f i it follows for all i = 1 , . . . , q that

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

Rearranging yields

<!-- formula-not-decoded -->

Since the sum of PSD matrices is also PSD, we have

<!-- formula-not-decoded -->

Adding zero in the form 0 = B -B yields

<!-- formula-not-decoded -->

Rearranging yields the desired inequality proving convexity:

<!-- formula-not-decoded -->

Lemma VI.3. The mapping H : R n → S p is matrix convex if H is in the form

<!-- formula-not-decoded -->

for some symmetric B ∈ S p and f j : R n → R , and at least one of the following conditions holds for each j ∈ 1 , . . . , J :

- 1) f j is affine in x and A j ∈ S p ,
- 2) f j is convex in x and A j ⪰ 0 ,
- 3) f j is concave in x and A j ⪯ 0 .

Proof. As per Definition 8, we proceed by proving that x ↦→ y ⊺ H ( x ) y is convex for all y ∈ R p . Consider the function

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

Case 1): If f j is linear in x , then y ⊺ By + ∑ J j =1 ( y ⊺ A j y ) f j ( x ) is an affine function of x which is both convex and concave.

Case 2): Observe that y ⊺ A j y ≥ 0 since A j ⪰ 0 . This implies that y ⊺ By + ∑ J j =1 ( y ⊺ A j y ) f j ( x ) is the sum of convex functions each multiplied by a nonnegative scalar, added to a constant value. This results in a convex function.

Case 3): Observe that y ⊺ A j y ≤ 0 since A j ⪯ 0 . This implies that y ⊺ By + ∑ J j =1 ( y ⊺ A j y ) f j ( x ) is the sum of concave functions each multiplied by a nonpositive scalar, added to a constant value. This results in a convex function.

Lemma VI.4. The mapping H : R n → S p is matrix concave if H is in the form

<!-- formula-not-decoded -->

for some symmetric B ∈ S p and at least one of the following conditions holds for each j ∈ 1 , . . . , J :

- f j is affine in x and A j ∈ S p ,
- f j is concave in x and A j ⪰ 0 ,
- f j is convex in x and A j ⪯ 0 .

Proof. Follows from similar arguments as Lemma VI.3, using Definition 9.

## REFERENCES

- [1] J. Breeden and D. Panagou, 'Autonomous spacecraft attitude reorientation using robust sampled-data control barrier functions,' Journal of Guidance, Control, and Dynamics , vol. 46, no. 10, pp. 1874-1891, 2023.
- [2] T. G. Molnar, S. K. Kannan, J. Cunningham, K. Dunlap, K. L. Hobbs, and A. D. Ames, 'Collision avoidance and geofencing for fixed-wing aircraft with control barrier functions,' IEEE Transactions on Control Systems Technology , 2025.
- [3] F. Ferraguti, C. T. Landi, A. Singletary, H.-C. Lin, A. Ames, C. Secchi, and M. Bonfe, 'Safety and efficiency in robotics: The control barrier functions approach,' IEEE Robotics &amp; Automation Magazine , vol. 29, no. 3, pp. 139-151, 2022.
- [4] W. S. Cortez, D. Oetomo, C. Manzie, and P. Choong, 'Control barrier functions for mechanical systems: Theory and application to robotic grasping,' IEEE Transactions on Control Systems Technology , vol. 29, no. 2, pp. 530-545, 2019.
- [5] Y. Chen, H. Peng, and J. Grizzle, 'Obstacle avoidance for low-speed autonomous vehicles with barrier function,' IEEE Transactions on Control Systems Technology , vol. 26, no. 1, pp. 194-206, 2017.
- [6] A. Alan, A. J. Taylor, C. R. He, A. D. Ames, and G. Orosz, 'Control barrier functions and input-to-state safety with application to automated vehicles,' IEEE Transactions on Control Systems Technology , vol. 31, no. 6, pp. 2744-2759, 2023.
- [7] K. Garg, J. Usevitch, J. Breeden, M. Black, D. Agrawal, H. Parwana, and D. Panagou, 'Advances in the theory of control barrier functions: Addressing practical challenges in safe control synthesis for autonomous and robotic systems,' Annual Reviews in Control , vol. 57, p. 100 945, 2024.
- [8] A. Agrawal and K. Sreenath, 'Discrete control barrier functions for safety-critical control of discrete systems with application to bipedal robot navigation.,' in Robotics: Science and Systems , Cambridge, MA, USA, vol. 13, 2017, pp. 1-10.
- [9] R. Cosner, P. Culbertson, A. Taylor, and A. Ames, 'Robust Safety under Stochastic Uncertainty with Discrete-Time Control Barrier Functions,' in Proceedings of Robotics: Science and Systems , Daegu, Republic of Korea, 2023.
- [10] J. Zeng, B. Zhang, and K. Sreenath, 'Safety-critical model predictive control with discrete-time control barrier function,' in 2021 American Control Conference (ACC) , IEEE, 2021, pp. 3882-3889.
- [11] S. Liu, J. Zeng, K. Sreenath, and C. A. Belta, 'Iterative convex optimization for model predictive control with discrete-time highorder control barrier functions,' in 2023 American Control Conference (ACC) , IEEE, 2023, pp. 3368-3375.
- [12] M. Khajenejad, M. Cavorsi, R. Niu, Q. Shen, and S. Z. Yong, 'Tractable compositions of discrete-time control barrier functions with application to driving safety control,' in 2021 European Control Conference (ECC) , IEEE, 2021, pp. 1303-1309.
- [13] M. Ahmadi, A. Singletary, J. W. Burdick, and A. D. Ames, 'Safe policy synthesis in multi-agent pomdps via discrete-time barrier functions,' in 2019 IEEE 58th Conference on Decision and Control (CDC) , IEEE, 2019, pp. 4797-4803.
- [14] P. Ong, Y. Xu, R. M. Bena, F. Jabbari, and A. D. Ames, 'Matrix control barrier functions,' arXiv preprint arXiv:2508.11795 , 2025.
- [15] P. Ong, H. Lee, T. G. Molnar, D. Panagou, and A. D. Ames, 'Combinatorial control barrier functions: Nested boolean and p-choose-r compositions of safety constraints,' arXiv preprint arXiv:2509.10716 , 2025.
- [16] R. A. Horn and C. R. Johnson, Matrix analysis . Cambridge university press, 2012.
- [17] R. T. Rockafellar and R. J. Wets, Variational analysis . Springer, 1998.
- [18] S. P. Boyd and L. Vandenberghe, Convex optimization . Cambridge university press, 2004.
- [19] A. Agrawal, B. Amos, S. Barratt, S. Boyd, S. Diamond, and J. Z. Kolter, 'Differentiable convex optimization layers,' Advances in neural information processing systems , vol. 32, 2019.
- [20] J. A. Paredes Salazar, J. Usevitch, and A. Goel, 'Predictive control barrier functions for discrete-time linear systems with unmodeled delays,' arXiv preprint arXiv:2510.01059 , 2025.
- [21] P. Seiler, M. Jankovic, and E. Hellstrom, 'Control barrier functions with unmodeled input dynamics using integral quadratic constraints,' IEEE Contr. Syst. Lett. , vol. 6, pp. 1664-1669, 2021.