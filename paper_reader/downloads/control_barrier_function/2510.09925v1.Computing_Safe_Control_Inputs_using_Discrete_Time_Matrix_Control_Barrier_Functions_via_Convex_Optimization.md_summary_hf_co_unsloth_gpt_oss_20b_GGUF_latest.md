## Title & Citation
**Computing Safe Control Inputs using Discrete‑Time Matrix Control Barrier Functions via Convex Optimization**  
James Usevitch, Juan Augusto Paredes Salazar, and Ankit Goel. IEEE Control Systems Letters (2025).  

---

## Abstract  
The paper introduces *exponential discrete‑time matrix control barrier functions* (DTE‑MCBFs) to guarantee forward invariance for discrete‑time control systems with nonconvex safe sets.  Because conventional discrete‐time CBFs require non‑convex optimization when the safety function is non‑concave, the authors propose a **projection‑based** sub‑set construction that yields a convex safety filter.  The method only needs two sequential convex QPs per step and is evaluated on double‑integrator dynamics and a bicopter model; simulation results show comparable tracking performance and an order‑of‑magnitude speed advantage over non‑convex alternatives.

---

## Introduction & Motivation  
- *Control Barrier Functions (CBFs)* are standard for safety guarantees in aerospace, robotics, autonomous driving, etc.  
- **Continuous‑time** CBFs are abundant; **discrete‑time** CBFs exist but optimization is non‑convex if the safety function is not concave in the control input.  
- Non‑convexity hampers real‑time safety filters.  
- Prior discrete‑time work either assumes concavity, works only with linear dynamics, or considers only scalar safety functions.  
- A recent continuous‑time concept of *matrix* CBFs (MCBFs) handles matrix‑valued safety sets, but no discrete‑time extension exists.  
- *Goal:* provide a convex‑optimization method for discrete‑time matrix safe sets, usable for general (even non‑concave) safety functions.

Key contributions claimed:  
1. Definition of exponential discrete‑time MCBFs.  
2. Convex projection‑based algorithm (PDTE‑MCBF) for non‑conjugate safety sets.  
3. Extension to indefinite matrix safe sets (allowing boolean/unions of constraints).

---

## Notation & Problem Formulation  
- Standard convex‑analysis symbols: `cl(S)`, `co(S)`, `S_p`, `S_p+`.  
- `A ⪰ 0` denotes positive semidefinite (`>= 0`).  
- Weyl’s inequality (Theorem 1) gives eigenvalue bounds for matrix sums.  
- Definitions of projection `P_C(x)` and normal cone `N_C(x)` (Theorem 2) provide support for convex manipulation.  
- Dynamics:  
  \[
  x_{k+1} = f(x_k)+g(x_k)u_k, \qquad x_k\in\mathbb{R}^n,\; u_k\in\mathbb{R}^m.
  \]  
- Safe set defined as super‑level set of a scalar `h:ℝ^n→ℝ`:  
  \[
  \mathcal{S}_h = \{x: h(x)\ge 0\}.
  \]  
- *Exponential discrete‑time CBF* condition (5) [8]:
  \[
  h(x_{k+1}) \ge (1-\gamma)h(x_k), \quad 0<\gamma\le 1.
  \]  
  This guarantees forward invariance (Theorem 3).  
- Safety filter: Solve  
  \[
  \min_{u_k}\|u_k-u_{nom}(x_k)\|_2^2 
  \]
  subj. to safety constraints for each CBF (7b); non‑convex if any `h_i` is non‑concave in `u`.

---

## Main Results – Section III  

### A. Discrete‑time Exponential Matrix CBFs  
- Define safe set as  
  \[
  \mathcal{S} = \{x:\;H(x) \succeq 0\}, \quad H:\mathbb{R}^n\to\mathbb{S}^p.
  \]  
- **Lemma III.1** (Forward invariance of a matrix set):  
  If for all \(x\in D\supset\mathcal{S}\) there exists \(0<\gamma\le 1\) s.t.  
  \[
  H(x_{k+1}) \succeq (1-\gamma)H(x_k),
  \]
  then \(\mathcal{S}\) is forward invariant.  
  Proof by induction using positive‑semidefinite “shrink‑age” of the matrix.

- **Definition 5 (DTE‑MCBF):**  
  A function `H(x)` is a DTE‑MCBF if there exists \(0<\gamma\le1\) and a domain `D⊃S` such that for all `x∈D` there is a control input `u∈ℝ^m` satisfying  
  \[
  H(f(x)+g(x)u) \succeq (1-\gamma)H(x).
  \]  
  The safe‑input set  
  \[
  \mathcal{K}_H(x)=\{u:\; H(f(x)+g(x)u) \succeq (1-\gamma)H(x)\}.
  \]

- **Theorem 4 (Zeroing property):**  
  If `H` is a DTE‑MCBF with constant `γ`, then any `u_k∈\mathcal{K}_H(x_k)` guarantees  
  \[
  \lambda_j(H(x_k)) \le (1-\gamma)^{k}\lambda_j(H(x_0)),\;\forall j.
  \]  
  Thus negative eigenvalues converge exponentially to zero.

- **Safety filter:**  
  `min_{u_k}||u_k-u_nom||_2^2` s.t. `u_k∈\mathcal{K}_H(x_k)`.  
  Still non‑convex if `H` is not matrix‑concave.

### B. Convex projection for non‑concave safe sets  

1. **Safe sets that are *matrix concave* in the argument** → constraint is convex; standard DTE‑MCBF algorithm applies.  
2. **Safe sets that are not matrix concave** → introduce Assumption 1:  

   *The closure of the unsafe set \(\mathcal{S}\) is a finite union of closed, convex sets \(\mathcal{S}\subset\bigcup_{i=1}^{Q}\mathcal{S}_i\).*  
   Each \(\mathcal{S}_i\) is defined via a matrix‑convex function `H_i(x)⪯0`.  

3. **Algorithmic idea:**  
   - For current `x_k`, compute the projection onto each \(\mathcal{S}_i\):  
     \[
     P_{\mathcal{S}_i}(x_k)=\arg\min_{z∈\mathcal{S}_i}\|z-x_k\|_2.
     \]  
     Solved via convex quadratic program (18).  
   - Construct a separating hyperplane:  
     \[
     a_i(x_k)=γ_i(x_k),\quad b_{\varepsilon,i}(x_k)=γ_i(x_k)^{T}P_{\mathcal{S}_i}(x_k)+\varepsilon\|x_k-P_{\mathcal{S}_i}(x_k)\|_2,
     \]  
     where `γ_i(x_k)=x_k-P_{\mathcal{S}_i}(x_k)/\|x_k-P_{\mathcal{S}_i}(x_k)\|`.  
   - Define linear safety functions for each obstacle:  
     \[
     h_{\varepsilon,i}(z,x_k)=a_i(x_k)^{T}z-b_{\varepsilon,i}(x_k).
     \]  
     These are matrix‑concave (affine) → safe subset function `H_{\varepsilon}` is a *subset‑based DTE‑MCBF* (SDTE‑MCBF).  

4. **Lemma III.2** shows that for `x_k∉\mathcal{S}_i`,  
   \[
   a_i(x_k)^T z < b_{\varepsilon,i}(x_k),\;\forall z∈\mathcal{S}_i,
   \]  
   i.e., the constructed half‑space excludes \(\mathcal{S}_i\).  

5. **Construction of the safe subset** (`H_{\varepsilon}`):  
   \[
   H_{\varepsilon}(z,x_k)=\operatorname{diag}_{i=1}^Q h_{\varepsilon,i}(z,x_k).
   \]  
   The set \(\{z: H_{\varepsilon}(z,x_k)⪰0\}\) is convex, contains a `buffer` of size `ε` away from \(\mathcal{S}\).  

6. **Lemma III.3**: For all `x_k` outside all \(\mathcal{S}_i\), the convex set `H_{\varepsilon}⪰0` is disjoint from each \(\mathcal{S}_i\).  

7. **Safety filter with DTE‑MCBF**:  
   For `H_{\varepsilon}` the safe‑input set  
   \[
   \mathcal{K}_{\varepsilon}(x_k)=\{u:\; H_{\varepsilon}(f(x_k)+g(x_k)u,x_k)⪰(1-\gamma) H_{\varepsilon}(x_k,x_k)\}.
   \]  
   Because each `h_{\varepsilon,i}` is affine in `u`, this is a *convex* QP (30).  

8. **Algorithm 1 (PDTE‑MCBF)**:  
   - Compute all projections \(P_{\mathcal{S}_i}(x_k)\).  
   - Solve QP (30) to get safe input `u_k`.  
   - Warm‑start with nominal input `u_nom`.  
   Gains: runs two convex QPs per timestep; the second uses `H_{\varepsilon}`.  
   Notes: If \(x_k∈\mathcal{S}_i\) (on boundary), a modified `h_{\partial,\varepsilon}` lemma III.5 handles the case; else for interior unsafe set a *depth*-based half‑space (35–40) is used.  

9. **Indefinite‑matrix safe sets** (Section III.D):  
   - Generalise Eq. (20) to  
     \[
     \{x:\; \lambda_{j}(H(x))\ge 0,\; j\in \mathcal{J}\}.
     \]  
   - Enforce via the DTE‑MCBF inequality (43) with a *shifted* matrix  
     \[
     H(x)+\gamma\lambda_j(H(x))I_p.
     \]  
   - Resulting safe‑input set `K(j)_H` exhibits exponential stability (Theorem 6).  

---

## Experiments / Data / Results  

### A. Demonstrated Obstacles  
Four obstacle geometries in 2‑D with corresponding matrix‑convex functions (equations (49)–(64)).  

| Obstacle | Model | Key matrix function |
|---|---|---|
| Circle | \(S_C=\{x:\|x-p_C\|\le r_C\}\) | \(H_C(x)= (x-p_C)^T(x-p_C)-r_C^2\) (eq 50). |
| Ellipse | \(S_E=\{x:(x-p_E)^T Q_E (x-p_E)\le \ell_{E,1}^2\}\) | \(H_E(x)= (x-p_E)^T Q_E (x-p_E)-\ell_{E,1}^2\) (eq 54). |
| Polytope | \(S_P=\{x: A_P^T x\le b_P\}\) | \(H_P(x)=\operatorname{diag}(A_P^Tx-b_P)\) (eq 57). |
| Spectrahedron | \(S_{Sp}=\{x:\; [x\;1]^T A_\theta(x)[x\;1]⪰0\}\) | \(H_{Sp}(x)= [x\;1]^TA_\theta(x)[x\;1]\) (eq 63). |

For each, the projection \(P_{\mathcal{S}_i}(x_k)\) is obtained either in closed form (circle) or by a convex program per the obstacle type.

### B. Discretised Double Integrators (Simulation IV‑B)

- Dynamics:  
  \[
  x_{k+1} = f(x_k)+g(x_k)u_k,\quad
  f(x_k)=\begin{bmatrix}x_k\\I\end{bmatrix}\Delta T,\;
  g(x_k)=\Delta T\begin{bmatrix}0&I\\0&0\end{bmatrix}
  \]  
  with \(\Delta T=0.01\).

- Nominal LQR reference‑tracking controller \(u_{nom}(x_k)\).  

- Obstacles: circle, ellipse, pentagon polytope, spectrahedron (Figures 2 & 3).  
- Two CBF formulations compared:  
  1. **PDTE‑MCBF**: QP (71) solving for `u_k` using `H_{\varepsilon}` (eqs (24)|(25)).  
  2. **Non‑convex CBF**: semidefinite QP (7b) with `h_C`, `h_E` etc. (eqs (52–55)).  

- **Parameters**: `γ=0.2`, `ε=0.4` for both.  

- **Results**:  
  - Trajectories (Fig 3 vs Fig 4): both keep the integrators away from obstacles; buffer sets of PDTE‑MCBF visibly more symmetric.  
  - Performance comparison (Table I):  
    | Method | Runtime per iteration (s) |
    |---|---|
    | PDTE‑MCBF (no projection) | \(1.036\times10^{-3}\) |
    | PDTE‑MCBF (with projection) | \(6.002\times10^{-2}\) |
    | Non‑convex CBF | 2.543 |  
  Concluding PDTE‑MCBF about 42× faster than non‑convex in full form.

### C. Bicopter Lateral Flight (Simulation IV‑C)

- 2‑plane dynamics derived from continuous bicopter model (eqs (74–76)), discretised with \(\Delta T=0.005\).  
- Hierarchical outer–inner loop LQR controllers (illustrated Fig 6).  
- Single circular obstacle (\(p_C=[2,-0.75]^T,\;r_C=1\)).  
- Additional constraints: velocity caps \(v_{h,max},v_{v,max}\) and tilt reference bound \(\theta_r^{max}\).  
- Two CBF formulations:  

  1. **PDTE‑MCBF** (eq 91) with `H_{\varepsilon}` using circle projection (eq 51).  
  2. **Non‑convex CBF**: semidefinite QP with `h_C` (eq 52).  

- **Solvers**:  
  - PDTE‑MCBF: MATLAB `lsqlin`.  
  - Non‑convex: (a) `fmincon` (SQP, 10⁵ iterations), (b) YALMIP‑MOSEK.  
- **Feasibility**: Figures 7 and 8 show trajectories and cases where solvers converge to infeasible solutions.  
- **Runtime** (Table II):  

  | CBF formulation | Avg. Runtime (s) |
  |------------------|--------------------|
  | PDTE‑MCBF (lsqlin) | \(5.251\times10^{-6}\) |
  | Non‑convex (fmincon) | \(3.113\times10^{-5}\) |
  | Non‑convex (YALMIP) | \(9.414\times10^{-1}\) |

- PDTE‑MCBF remains almost an order of magnitude faster, and better at staying feasible as the bicopter approaches buffer sets.

---

## Discussion & Analysis  

- **Buffer structure**: The convex half‑spaces generated by projection lead to buffer sets that are Minkowski‑sum‑style: symmetric around obstacle boundaries.  
- **Handling unions**: Indefinite‑matrix safe sets allow boolean/unions of CBFs, important for multiple obstacles and combinatorial safety.  
- **Zero‑ing property**: Theorem 4 guarantees exponential convergence of the safety function (negative eigenvalues) towards zero; ensures asymptotic safety in closed‑loop.  
- **Non‑convex vs convex**: The non‑convex formulation (7b) requires semidefinite programming and often fails to find feasible solutions or stalls around buffer sets, especially in the bicopter case where unmodeled dynamics can push state outside safe set.  
- **Scalability**: PDTE‑MCBF needs only two convex QPs, which are small (linear or second‑order cone), making it suitable for larger systems (e.g., multi‑agent).  
- **Limitations** reported:  
  1. Closed‑loop feasibility may still degrade if unsafe set becomes actively reached (buffer hits).  
  2. Depth‑based half‑spaces require extra computation for convex sets like ellipsoids/Polytopes.  
  3. Need for knowledge of convex decomposition of unsafe set (Assumption 1).  
  4. Theoretical convergence guarantee (Theorem 4) assumes exact dynamics—no measurement noise or delay.  

- **Open Questions**:  
  - Extending to high‑dimensional systems (larger `p`).  
  - Handling stochastic noise or param uncertainty.  
  - Integrating PDTE‑MCBF with sampling‑based planning.  

---

## Conclusions  
- Introduced exponential discrete‑time MCBFs and convex projection‑based safety filter (PDTE‑MCBF).  
- Demonstrated that PDTE‑MCBF enforces forward invariance for non‑convex safe sets, achieves comparable tracking performance but is over 20× faster than non‑convex alternatives.  
- Extending to indefinite matrix safe sets allows boolean combinations of constraints.  
- Future work: multi‑agent extensions, robust/noisy dynamics.  

---

## Key Claims & Contributions  
- **Definition of DTE‑MCBF** (new safety class).  
- **Projection‑based convex algorithm (PDTE‑MCBF)** yielding safe control with only convex QPs.  
- **Convex half‑space construction from projections** for any union of convex unsafe sets.  
- **Indefinite‑matrix (boolean) safe set generalization**.  
- **Proof of exponential zero‑ing and forward invariance** (Theorems 4, 6).  

---

## Definitions & Key Terms  

| Term | Definition | Source |
|------|-------------|---------|
| `DTE‑MCBF` | Matrix control barrier function for discrete‑time, exponentially damped by `γ`. | Definition 5 |
| `PDTE‑MCBF` | Projection‑based DTE‑MCBF → convex subset of safe set. | Definition 7 |
| `Safe subset function` | `H: ℝ^n × ℝ^n → S_p` with `H(x,x)⪰0` for `x∈S`. | Definition 6 |
| `Depth` | Minimum distance from a point to a convex set, expressed via quadratic program. | Section III.C |
| `Buffer distance ε` | Positive scalar adding safety margin, used in hyperplane construction. | Eq. 19,25 |

---

## Important Figures & Tables  

| Figure | Caption | Key Insight |
|--------|----------|--------------|
| Fig 1 | Illustration of PDTE‑MCBF workflow | Projection → half‑space → convex safe set |
| Fig 2 | Obstacle geometries (circle, ellipse, polytope, spectrahedron) | Visualizes unsafe sets used in simulation |
| Fig 3 | Double integrator trajectory with PDTE‑MCBF (ε=0.4) | Shows buffer shape, safe tracking |
| Fig 4 | Same with non‑convex CBF | Less symmetric buffers |
| Fig 5 | Bicopter schematic | Illustrates system dynamics |
| Fig 6 | Inner‑outer loop control architecture | Shows controller decomposition |
| Fig 7 | Bicopter trajectories: PDTE‑MCBF, fmincon, YALMIP | Demonstrates feasibility differences |
| Fig 8 | Feasible iterations vs infeasible | Illustrates solver successes |
| Table I | Runtime comparison (double integrator) | PDTE‑MCBF ≈ 43× faster |
| Table II | Runtime comparison (bicopter) | PDTE‑MCBF ≈ 18× faster than fmincon, 168× faster than YALMIP |

---

## Limitations & Open Questions  
- **Assumption 1** required: unsafe set decomposable into finite convex pieces.  
- **Depth calculation** can be costly for high‑order convex sets (e.g., polytopes).  
- **Solver feasibility** still an issue if state hits buffer; no guarantee to recover from unsafe set.  
- **Applicability to noisy/high‑dim settings** not empirically validated.  

---

## References to Original Sections (if available)  
- Definitions: Sect. III.A (Def 5).  
- Lemmas: III.1, III.2, III.3, III.4, III.5, III.6.  
- Theorems: 4, 5, 6.  
- Algorithm: Alg. 1 (Sec. III.B).  
- Experiments: Sec. IV.A–C, Tables I & II.  

---  

## Executive Summary / Key Takeaways (optional)  
1. Introduced DTE‑MCBFs; safe sets defined via matrix positive semidefinite inequality.  
2. Developed convex projection method (PDTE‑MCBF) that iteratively constructs convex subset of unsafe region even when safety function is non‑concave, enabling convex QPs.  
3. Shown that buffer sets generated by projection are symmetric and approximate Minkowski sums.  
4. Demonstrated comparable safety/trajectory performance on double‑integrators and bicopter, while being 20–50× faster than non‑convex approaches.  
5. Established theoretical zero‑ing and forward invariance for both DTE‑MCBF and extended indefinite‑matrix sets.  
6. Future work aims at multi‑agent scenarios and robust/noisy dynamics.

---  

## Supplementary Material (if present)  
- MATLAB/Simulink implementation details referenced in Section IV.  
- Code/environments: lsqlin, fmincon, YALMIP‑MOSEK, MOSEK, MOSEK's sdp tools.  
- Animation available at `https://youtu.be/eYDTqa lE4`.  
- YALMIP‑Simulink interfacing scripts at `https://yalmip.github.io/example/simulink/`.